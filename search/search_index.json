{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Teselas Vectoriales en la IDE Bienvenidos al taller de teselas vectoriales en la IDE. Este manual est\u00e1 publicado aqu\u00ed: http://geomati.co/taller-vt-jiide !!! danger Requisito imprescindible es tener un navegador con capacidades WebGL. Gui\u00f3n del taller Concepto de tesela vectorial : Qu\u00e9 es, formato pbf, especificaci\u00f3n mvt. [Caso pr\u00e1ctico: PostGIS] Creaci\u00f3n y almacenaje de teselas vectoriales: fichero mbtiles. [Caso pr\u00e1ctico: tippecanoe] Servicio b\u00e1sico de teselas vectoriales: Especificaci\u00f3n TileJSON, servicio XYZ. [Caso pr\u00e1ctico: tilserver-gl] Integraci\u00f3n de teselas vectoriales con servicios est\u00e1ndar OGC. [Caso pr\u00e1ctico: geoserver] Formatos usados para los iconos y las tipograf\u00edas : sprites y glyphs. [Caso pr\u00e1ctico: mapbox/spritezero, openmaptiles/fonts] Especificaci\u00f3n de estilo \"Mapbox GL Style spec\". [Caso pr\u00e1ctico: sources, layers y expressions] Visor web basado en \"Mapbox GL JS\". [Caso pr\u00e1ctico: \"Menorca Online\"] Recursos adicionales Autores Oscar Fonts @oscarfonts , desarrollador freelance en geomati.co Wladimir Szczerban (alias Bolo) @bolosig , geostarter (ICGC) Micho Garc\u00eda @michogar , desarrollador freelance en geomati.co Condiciones de reutilizaci\u00f3n de estos apuntes Estos materiales est\u00e1n publicados bajo licencia CreativeCommons (by-sa) 4.0 internacional Usted es libre de: Compartir \u2014 copiar y redistribuir el material en cualquier medio o formato Adaptar \u2014 remezclar, transformar y crear a partir del material para cualquier finalidad, incluso comercial. Bajo las condiciones siguientes: Reconocimiento \u2014 Debe reconocer adecuadamente la autor\u00eda, proporcionar un enlace a la licencia e indicar si se han realizado cambios. Puede hacerlo de cualquier manera razonable, pero no de una manera que sugiera que tiene el apoyo del licenciador o lo recibe por el uso que hace. CompartirIgual \u2014 Si remezcla, transforma o crea a partir del material, deber\u00e1 difundir sus contribuciones bajo la misma licencia que el original. No hay restricciones adicionales \u2014 No puede aplicar t\u00e9rminos legales o medidas tecnol\u00f3gicas que legalmente restrinjan realizar aquello que la licencia permite.","title":"Home"},{"location":"#teselas-vectoriales-en-la-ide","text":"Bienvenidos al taller de teselas vectoriales en la IDE. Este manual est\u00e1 publicado aqu\u00ed:","title":"Teselas Vectoriales en la IDE"},{"location":"#httpgeomaticotaller-vt-jiide","text":"!!! danger Requisito imprescindible es tener un navegador con capacidades WebGL.","title":"http://geomati.co/taller-vt-jiide"},{"location":"#guion-del-taller","text":"Concepto de tesela vectorial : Qu\u00e9 es, formato pbf, especificaci\u00f3n mvt. [Caso pr\u00e1ctico: PostGIS] Creaci\u00f3n y almacenaje de teselas vectoriales: fichero mbtiles. [Caso pr\u00e1ctico: tippecanoe] Servicio b\u00e1sico de teselas vectoriales: Especificaci\u00f3n TileJSON, servicio XYZ. [Caso pr\u00e1ctico: tilserver-gl] Integraci\u00f3n de teselas vectoriales con servicios est\u00e1ndar OGC. [Caso pr\u00e1ctico: geoserver] Formatos usados para los iconos y las tipograf\u00edas : sprites y glyphs. [Caso pr\u00e1ctico: mapbox/spritezero, openmaptiles/fonts] Especificaci\u00f3n de estilo \"Mapbox GL Style spec\". [Caso pr\u00e1ctico: sources, layers y expressions] Visor web basado en \"Mapbox GL JS\". [Caso pr\u00e1ctico: \"Menorca Online\"] Recursos adicionales","title":"Gui\u00f3n del taller"},{"location":"#autores","text":"Oscar Fonts @oscarfonts , desarrollador freelance en geomati.co Wladimir Szczerban (alias Bolo) @bolosig , geostarter (ICGC) Micho Garc\u00eda @michogar , desarrollador freelance en geomati.co Condiciones de reutilizaci\u00f3n de estos apuntes Estos materiales est\u00e1n publicados bajo licencia CreativeCommons (by-sa) 4.0 internacional Usted es libre de: Compartir \u2014 copiar y redistribuir el material en cualquier medio o formato Adaptar \u2014 remezclar, transformar y crear a partir del material para cualquier finalidad, incluso comercial. Bajo las condiciones siguientes: Reconocimiento \u2014 Debe reconocer adecuadamente la autor\u00eda, proporcionar un enlace a la licencia e indicar si se han realizado cambios. Puede hacerlo de cualquier manera razonable, pero no de una manera que sugiera que tiene el apoyo del licenciador o lo recibe por el uso que hace. CompartirIgual \u2014 Si remezcla, transforma o crea a partir del material, deber\u00e1 difundir sus contribuciones bajo la misma licencia que el original. No hay restricciones adicionales \u2014 No puede aplicar t\u00e9rminos legales o medidas tecnol\u00f3gicas que legalmente restrinjan realizar aquello que la licencia permite.","title":"Autores"},{"location":"01_que_son/","text":"Concepto de tesela vectorial Presentaci\u00f3n Ver este cap\u00edtulo en formato presentaci\u00f3n Est\u00e1ndares de codificaci\u00f3n de las teselas vectoriales Transformaci\u00f3n de una capa de datos a una tesela de imagen o tesela vectorial Teselas vectoriales Teselas de imagen Estilo se define en el cliente Estilo se define en el servidor S\u00f3lo se necesita teselar la informaci\u00f3n una sola vez y se pueden tener m\u00faltiples mapas Hay que teselas la informaci\u00f3n para cada mapa Overzoom se mantiene resoluci\u00f3n Overzoom pierde resoluci\u00f3n (pixelado) Menor tama\u00f1o (se recomienda m\u00e1ximo 500kb) M\u00e1s f\u00e1ciles de consumir Cache ocupa mucho menos espacio. F\u00e1ctible el uso en dispositivos m\u00f3viles sin conexi\u00f3n Cache ocupa mucho espacio. Uso en dispositivos m\u00f3viles requiere mucho espacio de disco Acceso nativo a la informaci\u00f3n del objeto (atributos y geometr\u00eda), lo que permite un procesamiento muy sofisticado Se ven mejor en dispositivos de alta resoluci\u00f3n Comparativa pesos teselas vector vs imagen. Fuente https://plot.ly/~mourner/118.embed Overzoom Overzooming es una t\u00e9cnica espec\u00edfica de teselas vectorial que permite que una tesela se represente m\u00e1s all\u00e1 de su nivel de zoom previsto, por lo que contin\u00faa siendo visible en el mapa. Si un conjunto de teselas tiene un minzoom de 6 y un maxzoom de 12, esos son los rangos v\u00e1lidos calculados por el generador de teselas. Si ampliara el mapa m\u00e1s all\u00e1 del nivel de zoom 12, el renderizador del mapa puede seguir utilizando los datos del zoom 12 escalando los datos del vector hacia arriba. Esto, por supuesto, puede dar lugar a grandes simplificaciones de datos si las geometr\u00edas se representan demasiado por encima de su nivel real de detalle. Las teselas imagen pierden claridad si ocurre overzoom. Por ejemplo, si est\u00e1 visualizando un conjunto de teselas imagen con una extensi\u00f3n de zoom entre z0 y z6, si hace un zoom a un nivel de zoom m\u00e1s alto despu\u00e9s de z6, las im\u00e1genes se volver\u00e1n borrosas y dif\u00edciles de ver. Los efectos del overzoom no son tan notables con las teselas vector, ya que los datos vectoriales no se almacenan en un formato basado en p\u00edxeles, sino que se codifican y calculan a partir de una serie de puntos, l\u00edneas y pol\u00edgonos. Overzoom nivel zoom 16 vs nivel zoom 19. Codificaci\u00f3n Las geometr\u00edas y los atributos se codifican como datos binarios de Google Protobuf (PBF). Codificar geometr\u00edas Para codificar informaci\u00f3n geogr\u00e1fica en una tesela vectorial, una herramienta debe convertir las coordenadas geogr\u00e1ficas, como la latitud y la longitud, en coordenadas vectoriales de cuadr\u00edculas. Las teselas de vectoriales no tienen ning\u00fan concepto de informaci\u00f3n geogr\u00e1fica. Codifican puntos, l\u00edneas y pol\u00edgonos como pares x/y relativos a la esquina superior izquierda de la cuadr\u00edcula de forma descendente. Las geometr\u00edas son transformadas a una sola tesela, con un sistema de coordenadas de p\u00edxel local, que por defecto va de la esquina superior izquierda (0,0) a la esquina inferior derecha (4096,4096). Codificar geometr\u00eda. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-geom Codificar atributos Los atributos se codifican como un conjunto \u00fanico de claves (algo as\u00ed como un esquema de campos de capa) y la lista de sus valores. Los atributos est\u00e1n codificados en una serie de etiquetas que existen dentro de un elemento en el vector que tienen valores enteros que hacen referencia a las claves y los valores que provienen de la geometr\u00eda. Esto elimina la redundancia de los atributos para geometr\u00edas que tienen las mismas claves y valores similares. Codificar atributos. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-attr Winding order El Winding order (direcci\u00f3n de digitalizaci\u00f3n) se refiere a la direcci\u00f3n en que se dibuja un anillo en un mosaico vectorial, ya sea en sentido horario o antihorario. Muchas geometr\u00edas son multipol\u00edgonos con \"agujeros\", que tambi\u00e9n se representan como anillos de pol\u00edgono. Es importante poder inferir el orden al extraer datos fuente de un mosaico vectorial y comprender si la geometr\u00eda es parte de un pol\u00edgono m\u00faltiple o un pol\u00edgono \u00fanico. Para que los procesadores distingan de manera apropiada que pol\u00edgonos son agujeros y cu\u00e1les son geometr\u00edas \u00fanicas, la especificaci\u00f3n requiere que todos los pol\u00edgonos sean v\u00e1lidos (validez de OGC). Cualquier anillo interior poligonal debe orientarse con el orden opuesto al de su anillo exterior principal y todos los anillos interiores deben seguir directamente el anillo exterior al que pertenecen. Los anillos exteriores deben estar orientados en el sentido de las agujas del reloj y los anillos interiores deben estar orientados en sentido contrario a las agujas del reloj. Winding order. Fuente https://www.mapbox.com/vector-tiles/specification/#winding-order Diferentes especificaciones y conceptos relacionados con las teselas vectoriales pbf Protocol buffers (pbf) desarrollado por Google (para uso interno) es un m\u00e9todo para serializar datos estructurados. Es language-neutral , platform-neutral y en cuyo objetivo de dise\u00f1o enfatizaron la simplicidad y el rendimiento. El m\u00e9todo implica un lenguaje de descripci\u00f3n de interfaz ( .proto ) que describe la estructura de algunos datos y un programa que genera c\u00f3digo fuente a partir de esa descripci\u00f3n para generar o analizar una secuencia de bytes que representa los datos estructurados. mvt Formato binario basado en la especificaci\u00f3n de Mapbox que usa pbf para serializar datos geogr\u00e1ficos. Los archivos deber\u00edan tener extensi\u00f3n .mvt pero no es obligatorio as\u00ed que se pueden encontrar archivos con extensi\u00f3n .pbf, .vector.pbf o .mvt.gz (compresi\u00f3n gzip) Por ejemplo un conjunto de teselas mvt almacenadas en un SQLite siguiendo una esquema espec\u00edfico formar\u00eda un MBTiles. Caso pr\u00e1ctico: Generando teselas vectoriales con PostGIS Desde PostGIS 2.4.0 existe la funci\u00f3n ST_AsMVT para generar teselas directamente con SQL. A partir de los recursos de este enlace: https://github.com/geomatico/taller-vt-jiide/tree/master/ejercicios/01 Cargar la base de datos vt_dump , que contiene los barrios de Barcelona, mediante psql. El comando ser\u00eda: 1 psql -U postgres -W lt; vt_dump.sql Conect\u00e1ndonos a la nueva base de datos vt , con usuario vt , y password vt : Creamos una funci\u00f3n auxiliar que calcula el BBOX de una tesela en funci\u00f3n de los par\u00e1metros (x, y, z): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 CREATE OR REPLACE FUNCTION BBox ( z integer , x integer , y integer ) RETURNS geometry AS $ BODY $ DECLARE max numeric := 6378137 * pi (); res numeric := max * 2 / 2 ^ z ; BEGIN return ST_MakeEnvelope ( - max + ( x * res ), max - ( y * res ), - max + ( x * res ) + res , max - ( y * res ) - res , 3857 ); END ; $ BODY $ LANGUAGE plpgsql ; Ejecutamos la consulta que nos devuelve la tesela de zoom=13, x=4145 e y=3059, de la siguiente manera: 1 2 3 4 5 6 7 8 9 10 11 12 SELECT ST_AsMVT ( q , mvt_barrios ) FROM ( SELECT gid , n_barri , ST_AsMVTGeom ( geom , BBox ( 13 , 4145 , 3059 ), 4096 , 0 ) AS geom FROM barrios WHERE geom BBox ( 13 , 4145 , 3059 ) ) AS q ; La tesela resultante corresponder\u00eda a este \u00e1rea de Barcelona: Obviamente, generar una sola tesela no tiene sentido. Pero ya tenemos la pieza principal para construir un generador de pir\u00e1mides de teselas, o construir un servicio web de tipo {z}/{x}/{y} . Esta capacidad la utilizan m\u00faltiples implementaciones como tegola, t-rex, o el generador de teselas de OpenMapTiles, llamado postserve .","title":"1. Qu\u00e9 son"},{"location":"01_que_son/#concepto-de-tesela-vectorial","text":"Presentaci\u00f3n Ver este cap\u00edtulo en formato presentaci\u00f3n","title":"Concepto de tesela vectorial"},{"location":"01_que_son/#estandares-de-codificacion-de-las-teselas-vectoriales","text":"Transformaci\u00f3n de una capa de datos a una tesela de imagen o tesela vectorial Teselas vectoriales Teselas de imagen Estilo se define en el cliente Estilo se define en el servidor S\u00f3lo se necesita teselar la informaci\u00f3n una sola vez y se pueden tener m\u00faltiples mapas Hay que teselas la informaci\u00f3n para cada mapa Overzoom se mantiene resoluci\u00f3n Overzoom pierde resoluci\u00f3n (pixelado) Menor tama\u00f1o (se recomienda m\u00e1ximo 500kb) M\u00e1s f\u00e1ciles de consumir Cache ocupa mucho menos espacio. F\u00e1ctible el uso en dispositivos m\u00f3viles sin conexi\u00f3n Cache ocupa mucho espacio. Uso en dispositivos m\u00f3viles requiere mucho espacio de disco Acceso nativo a la informaci\u00f3n del objeto (atributos y geometr\u00eda), lo que permite un procesamiento muy sofisticado Se ven mejor en dispositivos de alta resoluci\u00f3n Comparativa pesos teselas vector vs imagen. Fuente https://plot.ly/~mourner/118.embed","title":"Est\u00e1ndares de codificaci\u00f3n de las teselas vectoriales"},{"location":"01_que_son/#overzoom","text":"Overzooming es una t\u00e9cnica espec\u00edfica de teselas vectorial que permite que una tesela se represente m\u00e1s all\u00e1 de su nivel de zoom previsto, por lo que contin\u00faa siendo visible en el mapa. Si un conjunto de teselas tiene un minzoom de 6 y un maxzoom de 12, esos son los rangos v\u00e1lidos calculados por el generador de teselas. Si ampliara el mapa m\u00e1s all\u00e1 del nivel de zoom 12, el renderizador del mapa puede seguir utilizando los datos del zoom 12 escalando los datos del vector hacia arriba. Esto, por supuesto, puede dar lugar a grandes simplificaciones de datos si las geometr\u00edas se representan demasiado por encima de su nivel real de detalle. Las teselas imagen pierden claridad si ocurre overzoom. Por ejemplo, si est\u00e1 visualizando un conjunto de teselas imagen con una extensi\u00f3n de zoom entre z0 y z6, si hace un zoom a un nivel de zoom m\u00e1s alto despu\u00e9s de z6, las im\u00e1genes se volver\u00e1n borrosas y dif\u00edciles de ver. Los efectos del overzoom no son tan notables con las teselas vector, ya que los datos vectoriales no se almacenan en un formato basado en p\u00edxeles, sino que se codifican y calculan a partir de una serie de puntos, l\u00edneas y pol\u00edgonos. Overzoom nivel zoom 16 vs nivel zoom 19.","title":"Overzoom"},{"location":"01_que_son/#codificacion","text":"Las geometr\u00edas y los atributos se codifican como datos binarios de Google Protobuf (PBF).","title":"Codificaci\u00f3n"},{"location":"01_que_son/#codificar-geometrias","text":"Para codificar informaci\u00f3n geogr\u00e1fica en una tesela vectorial, una herramienta debe convertir las coordenadas geogr\u00e1ficas, como la latitud y la longitud, en coordenadas vectoriales de cuadr\u00edculas. Las teselas de vectoriales no tienen ning\u00fan concepto de informaci\u00f3n geogr\u00e1fica. Codifican puntos, l\u00edneas y pol\u00edgonos como pares x/y relativos a la esquina superior izquierda de la cuadr\u00edcula de forma descendente. Las geometr\u00edas son transformadas a una sola tesela, con un sistema de coordenadas de p\u00edxel local, que por defecto va de la esquina superior izquierda (0,0) a la esquina inferior derecha (4096,4096). Codificar geometr\u00eda. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-geom","title":"Codificar geometr\u00edas"},{"location":"01_que_son/#codificar-atributos","text":"Los atributos se codifican como un conjunto \u00fanico de claves (algo as\u00ed como un esquema de campos de capa) y la lista de sus valores. Los atributos est\u00e1n codificados en una serie de etiquetas que existen dentro de un elemento en el vector que tienen valores enteros que hacen referencia a las claves y los valores que provienen de la geometr\u00eda. Esto elimina la redundancia de los atributos para geometr\u00edas que tienen las mismas claves y valores similares. Codificar atributos. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-attr","title":"Codificar atributos"},{"location":"01_que_son/#winding-order","text":"El Winding order (direcci\u00f3n de digitalizaci\u00f3n) se refiere a la direcci\u00f3n en que se dibuja un anillo en un mosaico vectorial, ya sea en sentido horario o antihorario. Muchas geometr\u00edas son multipol\u00edgonos con \"agujeros\", que tambi\u00e9n se representan como anillos de pol\u00edgono. Es importante poder inferir el orden al extraer datos fuente de un mosaico vectorial y comprender si la geometr\u00eda es parte de un pol\u00edgono m\u00faltiple o un pol\u00edgono \u00fanico. Para que los procesadores distingan de manera apropiada que pol\u00edgonos son agujeros y cu\u00e1les son geometr\u00edas \u00fanicas, la especificaci\u00f3n requiere que todos los pol\u00edgonos sean v\u00e1lidos (validez de OGC). Cualquier anillo interior poligonal debe orientarse con el orden opuesto al de su anillo exterior principal y todos los anillos interiores deben seguir directamente el anillo exterior al que pertenecen. Los anillos exteriores deben estar orientados en el sentido de las agujas del reloj y los anillos interiores deben estar orientados en sentido contrario a las agujas del reloj. Winding order. Fuente https://www.mapbox.com/vector-tiles/specification/#winding-order","title":"Winding order"},{"location":"01_que_son/#diferentes-especificaciones-y-conceptos-relacionados-con-las-teselas-vectoriales","text":"","title":"Diferentes especificaciones y conceptos relacionados con las teselas vectoriales"},{"location":"01_que_son/#pbf","text":"Protocol buffers (pbf) desarrollado por Google (para uso interno) es un m\u00e9todo para serializar datos estructurados. Es language-neutral , platform-neutral y en cuyo objetivo de dise\u00f1o enfatizaron la simplicidad y el rendimiento. El m\u00e9todo implica un lenguaje de descripci\u00f3n de interfaz ( .proto ) que describe la estructura de algunos datos y un programa que genera c\u00f3digo fuente a partir de esa descripci\u00f3n para generar o analizar una secuencia de bytes que representa los datos estructurados.","title":"pbf"},{"location":"01_que_son/#mvt","text":"Formato binario basado en la especificaci\u00f3n de Mapbox que usa pbf para serializar datos geogr\u00e1ficos. Los archivos deber\u00edan tener extensi\u00f3n .mvt pero no es obligatorio as\u00ed que se pueden encontrar archivos con extensi\u00f3n .pbf, .vector.pbf o .mvt.gz (compresi\u00f3n gzip) Por ejemplo un conjunto de teselas mvt almacenadas en un SQLite siguiendo una esquema espec\u00edfico formar\u00eda un MBTiles.","title":"mvt"},{"location":"01_que_son/#caso-practico-generando-teselas-vectoriales-con-postgis","text":"Desde PostGIS 2.4.0 existe la funci\u00f3n ST_AsMVT para generar teselas directamente con SQL. A partir de los recursos de este enlace: https://github.com/geomatico/taller-vt-jiide/tree/master/ejercicios/01 Cargar la base de datos vt_dump , que contiene los barrios de Barcelona, mediante psql. El comando ser\u00eda: 1 psql -U postgres -W lt; vt_dump.sql Conect\u00e1ndonos a la nueva base de datos vt , con usuario vt , y password vt : Creamos una funci\u00f3n auxiliar que calcula el BBOX de una tesela en funci\u00f3n de los par\u00e1metros (x, y, z): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 CREATE OR REPLACE FUNCTION BBox ( z integer , x integer , y integer ) RETURNS geometry AS $ BODY $ DECLARE max numeric := 6378137 * pi (); res numeric := max * 2 / 2 ^ z ; BEGIN return ST_MakeEnvelope ( - max + ( x * res ), max - ( y * res ), - max + ( x * res ) + res , max - ( y * res ) - res , 3857 ); END ; $ BODY $ LANGUAGE plpgsql ; Ejecutamos la consulta que nos devuelve la tesela de zoom=13, x=4145 e y=3059, de la siguiente manera: 1 2 3 4 5 6 7 8 9 10 11 12 SELECT ST_AsMVT ( q , mvt_barrios ) FROM ( SELECT gid , n_barri , ST_AsMVTGeom ( geom , BBox ( 13 , 4145 , 3059 ), 4096 , 0 ) AS geom FROM barrios WHERE geom BBox ( 13 , 4145 , 3059 ) ) AS q ; La tesela resultante corresponder\u00eda a este \u00e1rea de Barcelona: Obviamente, generar una sola tesela no tiene sentido. Pero ya tenemos la pieza principal para construir un generador de pir\u00e1mides de teselas, o construir un servicio web de tipo {z}/{x}/{y} . Esta capacidad la utilizan m\u00faltiples implementaciones como tegola, t-rex, o el generador de teselas de OpenMapTiles, llamado postserve .","title":"Caso pr\u00e1ctico: Generando teselas vectoriales con PostGIS"},{"location":"02_crearlas/","text":"Creaci\u00f3n y almacenaje de teselas vectoriales Generar las teselas vectoriales al vuelo es lento, y se recomienda, en la medida de lo posible, tenerlas cacheadas. Almacenar una pir\u00e1mide de teselas en una estructura de directorios, cuando se tiene una cantidad importante de datos, es tambi\u00e9n ineficiente, por lo que Mapbox cre\u00f3 el foramto mbtiles. Especificaci\u00f3n .mbtiles Mbtiles contiene toda una pir\u00e1mide de teselas en un solo fichero, que es una BDD sqlite. Pir\u00e1mide de teselas guardada en una BDD SQLite, con un esquema determinado. Tablas principales: Vista tiles zoom_level tile_column tile_row tile_data {z} {x} {y} {BLOB} Tabla metadata name value format \" pbf \" attribution \"(c) OpenStreetMap...\" minZoom 0 maxZoom 14 BBOX -180,-85.06,180,85.06 json (capas contenidas en cada tesela, y su \"feature type\") Tip Un fichero mbtiles puede contener teselas de cualquier tipo, tambi\u00e9n de formato imagen. Esto no se deduce de la extensi\u00f3n del fichero. Warning Mbtiles no es equivalente a geopackage. Aunque ambos son esencialmente una BDD SQLite, guardan los datos en una estructura distinta y tienen diferente prop\u00f3sito. Tippecanoe Tippecanoe es la herramienta que permite crear teselas vectoriales de grandes colecciones de elementos en formato GeoJSON. El objetivo de Tippecanoe es permitir una visi\u00f3n de sus datos independiente de la escala, de modo que en cualquier nivel, desde el mundo entero hasta un solo edificio, se pueda apreciar la densidad y la textura de los datos, en lugar de una simplificaci\u00f3n geom\u00e9trica, que puede eliminar v\u00e9rtices importantes que cambien la apariencia de los datos en su versi\u00f3n simplificada. Algunos ejemplos: Teniendo todo el callejero de OpenStreetMap, la vista general devolver\u00e1 algo que se parece a \"Todas las calles\" en lugar de algo que parece un atlas de carreteras interestatal. Teniendo todas las plantas de edificios de una ciudad, en la vista general donde los edificios individuales ya no sean perceptibles, a\u00fan deber\u00edas poder ver la extensi\u00f3n y variedad del desarrollo en cada vecindario, no solo para los edificios m\u00e1s voluminosos. Esto hace que la calidad de los resultados de Tippecanoe sea muy superior a otras alternativas, que utilizan algoritmos de simplificaci\u00f3n m\u00e1s convencionales, motivo por el cual lo recomendamos en este taller. Adem\u00e1s, es sorprendentemente r\u00e1pido procesando los datos. Caso pr\u00e1ctico: generaci\u00f3n de una pir\u00e1mide de teselas vectoriales Instalar mapbox/tippecanoe . Esto es muy sencillo en un Mac con brew, algo menos sencillo en Ubuntu (hay que asegurarse de tener todas las dependencias y compilar), y no est\u00e1 definido c\u00f3mo compilarlo en Windows. Tip Tambi\u00e9n se puede usar alguna de las im\u00e1genes docker disponibles. A partir del fichero buildings.geojson en: https://github.com/geomatico/taller-vt-jiide/tree/master/ejercicios/02 Ejecutar el comando de tippecanoe: 1 tippecanoe -L buildingpart:buildingpart.geojson -Z 12 -z 16 -n Catastro Building Parts -o buildingpart.mbtiles -A Catastro Esto generar\u00e1 el fichero buildings.mbtiles . Abrir el fichero resultante con un administrador de bases de datos SQLite, y se podr\u00e1 observar la estructura de datos mencionada. QGIS tiene un plugin llamado \"Vector Tiles Reader\" para poder visualizar los datos. No es muy r\u00e1pido ni estable, pero puede servir para inspeccionar los datos.","title":"2. C\u00f3mo crearlas"},{"location":"02_crearlas/#creacion-y-almacenaje-de-teselas-vectoriales","text":"Generar las teselas vectoriales al vuelo es lento, y se recomienda, en la medida de lo posible, tenerlas cacheadas. Almacenar una pir\u00e1mide de teselas en una estructura de directorios, cuando se tiene una cantidad importante de datos, es tambi\u00e9n ineficiente, por lo que Mapbox cre\u00f3 el foramto mbtiles.","title":"Creaci\u00f3n y almacenaje de teselas vectoriales"},{"location":"02_crearlas/#especificacion-mbtiles","text":"Mbtiles contiene toda una pir\u00e1mide de teselas en un solo fichero, que es una BDD sqlite. Pir\u00e1mide de teselas guardada en una BDD SQLite, con un esquema determinado. Tablas principales:","title":"Especificaci\u00f3n .mbtiles"},{"location":"02_crearlas/#vista-tiles","text":"zoom_level tile_column tile_row tile_data {z} {x} {y} {BLOB}","title":"Vista tiles"},{"location":"02_crearlas/#tabla-metadata","text":"name value format \" pbf \" attribution \"(c) OpenStreetMap...\" minZoom 0 maxZoom 14 BBOX -180,-85.06,180,85.06 json (capas contenidas en cada tesela, y su \"feature type\") Tip Un fichero mbtiles puede contener teselas de cualquier tipo, tambi\u00e9n de formato imagen. Esto no se deduce de la extensi\u00f3n del fichero. Warning Mbtiles no es equivalente a geopackage. Aunque ambos son esencialmente una BDD SQLite, guardan los datos en una estructura distinta y tienen diferente prop\u00f3sito.","title":"Tabla metadata"},{"location":"02_crearlas/#tippecanoe","text":"Tippecanoe es la herramienta que permite crear teselas vectoriales de grandes colecciones de elementos en formato GeoJSON. El objetivo de Tippecanoe es permitir una visi\u00f3n de sus datos independiente de la escala, de modo que en cualquier nivel, desde el mundo entero hasta un solo edificio, se pueda apreciar la densidad y la textura de los datos, en lugar de una simplificaci\u00f3n geom\u00e9trica, que puede eliminar v\u00e9rtices importantes que cambien la apariencia de los datos en su versi\u00f3n simplificada. Algunos ejemplos: Teniendo todo el callejero de OpenStreetMap, la vista general devolver\u00e1 algo que se parece a \"Todas las calles\" en lugar de algo que parece un atlas de carreteras interestatal. Teniendo todas las plantas de edificios de una ciudad, en la vista general donde los edificios individuales ya no sean perceptibles, a\u00fan deber\u00edas poder ver la extensi\u00f3n y variedad del desarrollo en cada vecindario, no solo para los edificios m\u00e1s voluminosos. Esto hace que la calidad de los resultados de Tippecanoe sea muy superior a otras alternativas, que utilizan algoritmos de simplificaci\u00f3n m\u00e1s convencionales, motivo por el cual lo recomendamos en este taller. Adem\u00e1s, es sorprendentemente r\u00e1pido procesando los datos.","title":"Tippecanoe"},{"location":"02_crearlas/#caso-practico-generacion-de-una-piramide-de-teselas-vectoriales","text":"Instalar mapbox/tippecanoe . Esto es muy sencillo en un Mac con brew, algo menos sencillo en Ubuntu (hay que asegurarse de tener todas las dependencias y compilar), y no est\u00e1 definido c\u00f3mo compilarlo en Windows. Tip Tambi\u00e9n se puede usar alguna de las im\u00e1genes docker disponibles. A partir del fichero buildings.geojson en: https://github.com/geomatico/taller-vt-jiide/tree/master/ejercicios/02 Ejecutar el comando de tippecanoe: 1 tippecanoe -L buildingpart:buildingpart.geojson -Z 12 -z 16 -n Catastro Building Parts -o buildingpart.mbtiles -A Catastro Esto generar\u00e1 el fichero buildings.mbtiles . Abrir el fichero resultante con un administrador de bases de datos SQLite, y se podr\u00e1 observar la estructura de datos mencionada. QGIS tiene un plugin llamado \"Vector Tiles Reader\" para poder visualizar los datos. No es muy r\u00e1pido ni estable, pero puede servir para inspeccionar los datos.","title":"Caso pr\u00e1ctico: generaci\u00f3n de una pir\u00e1mide de teselas vectoriales"},{"location":"03_servirlas/","text":"Servicio b\u00e1sico de teselas vectoriales Un servicio de teselas a la google o de tipo \"XYZ\" consiste en una URL donde se sustituyen los valores de zoom, fila y columna siguiendo una plantilla, como en: http://tileserver.fonts.cat/data/buildingpart/{z}/{x}/{y}.pbf Se supone una proyecci\u00f3n determinada, EPSG:3857 , y un esquema de teselado determinado. Nada se sabe sobre el rango de zooms o el \u00e1mbito geogr\u00e1fico de los datos (BBXOX), su atribuci\u00f3n, o su contenido. Por ello mapbox ide\u00f3 un fichero de metadatos para publicar esta informaci\u00f3n de forma est\u00e1ndar: la especificaci\u00f3n TileJSON . Especificaci\u00f3n TileJSON Este fichero de \"metadatos\" vendr\u00eda a ser algo entre un GetCapabilities de m\u00ednimos, y un DescribeFeatureType: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { tilejson : 2.0.0 name : Catastro Building Parts , tiles :[ http://tileserver.fonts.cat/data/buildingpart/{z}/{x}/{y}.pbf ], minzoom : 14 , maxzoom : 16 , bounds : [ 2.038039 , 41.278439 , 2.268328 , 41.573783 ], type : overlay , attribution : Catastro , vector_layers : [ { id : buildingpart , minzoom : 14 , maxzoom : 16 , fields : { floors : Number , id : String , parcel : String } } ] } Caso pr\u00e1ctico: Explorando una instancia de Tileserver GL TileServer GL es un servidor de mapas de c\u00f3digo abierto creado para teselas vectoriales, y capaz de renderizar en teselas raster con MapBox GL Native engine en el lado del servidor. Proporciona mapas para aplicaciones web y m\u00f3viles. Es compatibles con Mapbox GL JS, Android SDK, iOS SDK, Leaflet, OpenLayers, HighDPI/Retina, SIG a trav\u00e9s de WMTS, etc. Si se quiere servir teselas raster lo mejor es utilizar la versi\u00f3n de Docker ya que son necesarias algunas librer\u00edas nativas que pueden variar dependiendo de la plataforma, estas librer\u00edas sirven para renderizar las teselas vectoriales en teselas raster. Si \u00fanicamente se quiere servir teselas vectoriales se puede utilizar el TileServer GL Light, que no tiene ninguna dependencia nativa ya que est\u00e1 desarrollado en javascript. Abrir http://tileserver.fonts.cat en un navegador Explorar la secci\u00f3n \"DATA\": Documento TileJSON Inspector Explorar la secci\u00f3n \"STYLES\": Documento TileJSON . No siempre. Diferencias con el anterior. Viewers: Vector y Raster. Similitudes y diferencias. Servicio WMTS. S\u00f3lo para imagen. Estructura de un documento GL Style: Sprites Glyphs (y el endpoint oculto: http://tileserver.fonts.cat/fonts.json ) Sources Layers","title":"3. C\u00f3mo servirlas"},{"location":"03_servirlas/#servicio-basico-de-teselas-vectoriales","text":"Un servicio de teselas a la google o de tipo \"XYZ\" consiste en una URL donde se sustituyen los valores de zoom, fila y columna siguiendo una plantilla, como en: http://tileserver.fonts.cat/data/buildingpart/{z}/{x}/{y}.pbf Se supone una proyecci\u00f3n determinada, EPSG:3857 , y un esquema de teselado determinado. Nada se sabe sobre el rango de zooms o el \u00e1mbito geogr\u00e1fico de los datos (BBXOX), su atribuci\u00f3n, o su contenido. Por ello mapbox ide\u00f3 un fichero de metadatos para publicar esta informaci\u00f3n de forma est\u00e1ndar: la especificaci\u00f3n TileJSON .","title":"Servicio b\u00e1sico de teselas vectoriales"},{"location":"03_servirlas/#especificacion-tilejson","text":"Este fichero de \"metadatos\" vendr\u00eda a ser algo entre un GetCapabilities de m\u00ednimos, y un DescribeFeatureType: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { tilejson : 2.0.0 name : Catastro Building Parts , tiles :[ http://tileserver.fonts.cat/data/buildingpart/{z}/{x}/{y}.pbf ], minzoom : 14 , maxzoom : 16 , bounds : [ 2.038039 , 41.278439 , 2.268328 , 41.573783 ], type : overlay , attribution : Catastro , vector_layers : [ { id : buildingpart , minzoom : 14 , maxzoom : 16 , fields : { floors : Number , id : String , parcel : String } } ] }","title":"Especificaci\u00f3n TileJSON"},{"location":"03_servirlas/#caso-practico-explorando-una-instancia-de-tileserver-gl","text":"TileServer GL es un servidor de mapas de c\u00f3digo abierto creado para teselas vectoriales, y capaz de renderizar en teselas raster con MapBox GL Native engine en el lado del servidor. Proporciona mapas para aplicaciones web y m\u00f3viles. Es compatibles con Mapbox GL JS, Android SDK, iOS SDK, Leaflet, OpenLayers, HighDPI/Retina, SIG a trav\u00e9s de WMTS, etc. Si se quiere servir teselas raster lo mejor es utilizar la versi\u00f3n de Docker ya que son necesarias algunas librer\u00edas nativas que pueden variar dependiendo de la plataforma, estas librer\u00edas sirven para renderizar las teselas vectoriales en teselas raster. Si \u00fanicamente se quiere servir teselas vectoriales se puede utilizar el TileServer GL Light, que no tiene ninguna dependencia nativa ya que est\u00e1 desarrollado en javascript. Abrir http://tileserver.fonts.cat en un navegador Explorar la secci\u00f3n \"DATA\": Documento TileJSON Inspector Explorar la secci\u00f3n \"STYLES\": Documento TileJSON . No siempre. Diferencias con el anterior. Viewers: Vector y Raster. Similitudes y diferencias. Servicio WMTS. S\u00f3lo para imagen. Estructura de un documento GL Style: Sprites Glyphs (y el endpoint oculto: http://tileserver.fonts.cat/fonts.json ) Sources Layers","title":"Caso pr\u00e1ctico: Explorando una instancia de Tileserver GL"},{"location":"04_OGC/","text":"Integraci\u00f3n de las teselas vectoriales con servicios est\u00e1ndar OGC Las teselas vectoriales est\u00e1n pensadas para su visualizaci\u00f3n , no son un servicio de descarga . Por tanto, la manera de servirlas mediante est\u00e1ndares OGC es usando WMTS para la versi\u00f3n teselada, e incluso WMTS si quisi\u00e9ramos servir el mismo formato pero sin el teselado. En definitiva, podr\u00edamos considerar las teselas vectoriales como un nuevo formato de \"imagen\". Igual que tenemos image/jpeg o image/png , podr\u00edamos inclu\u00edr un nuevo tipo MIME en las capabilities de nuestros servicios WMS y WMTS que sirviera los datos codificados en MVT. Esto es precisamente lo que hace la extensi\u00f3n Vector Tiles de GeoServer cuando define el nuevo tipo MIME: 1 application/x-protobuf;type=mapbox-vector Caso pr\u00e1ctico: La extensi\u00f3n Vector Tiles de GeoServer Entrar en http://demo.fonts.cat/geoserver/ Explorar el GetCapabilities del servicio WMS. Buscar c\u00f3mo est\u00e1n anunciadas las capas de teselas vectoriales. Explorar las Capabilities de los servicios WMTS, TMS y WMS-C, y comprobar si existen capas de teselas vectoriales. Entrar como administrador, y observar c\u00f3mo est\u00e1 configurado GeoWebCach\u00e9 para las capas que sirven teselas vectoriales. Discutir ventajas y limitaciones de GeoServer. Ejemplos de integraci\u00f3n con otros servicios de OGC WMS: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 sources : { wms-source : { type : raster , tiles : [ http://www.ign.es/wms-inspire/pnoa-ma?bbox={bbox-epsg-3857 } format=image/jpeg service=WMS version= 1.1 . 1 request=GetMap srs=EPSG: 3857 width= 256 height= 256 layers=OI.OrthoimageCoverage ], tileSize : 256 } }, layers : [{ id : wms-layer , type : raster , source : wms-source }] DEMO WMS imagen WMTS: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 sources : { wmts-source : { type : raster , tiles : [ http://www.ign.es/wmts/pnoa-ma?Layer=OI.OrthoimageCoverage Style=default TileMatrixSet=GoogleMapsCompatible Service=WMTS Request=GetTile Version=1.0.0 Format=image/jpeg TileMatrix={z } TileCol= { x } TileRow= { y } ], tileSize : 256 } }, layers : [{ id : wmts-layer , type : raster , source : wmts-source }] DEMO WMTS imagen WFS: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sources : { geojson-source : { type : geojson , data : http://demo.fonts.cat/geoserver/wfs?SERVICE=WFS VERSION=1.1.0 REQUEST=GetFeature TYPENAME=TMB:LINIES_METRO outputFormat=json srsName=EPSG:4326 } }, layers : [{ id : geojson-layer , type : line , source : geojson-source , paint : { line-width : 5, line-color : [ concat , # , [ get , COLOR_LINIA ]] } } ] DEMO WMTS imagen + WFS GeoJSON Teselas Vectoriales como TMS: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sources : { vectortile-tms-source : { type : vector , tiles : [ http://demo.fonts.cat:8000/geoserver/gwc/service/tms/1.0.0/TMB%3ALINIES_METRO@EPSG%3A900913@pbf/{z } / { x } / { y } .pbf ], scheme : tms } }, layers : [{ id : vectortile-layer , type : line , source : vectortile-tms-source , source-layer : LINIES_METRO , paint : { line-width : 5, line-color : [ concat , # , [ get , COLOR_LINIA ]] } } ] DEMO WMTS imagen + Vector Tile TMS","title":"4. Servicios est\u00e1ndar"},{"location":"04_OGC/#integracion-de-las-teselas-vectoriales-con-servicios-estandar-ogc","text":"Las teselas vectoriales est\u00e1n pensadas para su visualizaci\u00f3n , no son un servicio de descarga . Por tanto, la manera de servirlas mediante est\u00e1ndares OGC es usando WMTS para la versi\u00f3n teselada, e incluso WMTS si quisi\u00e9ramos servir el mismo formato pero sin el teselado. En definitiva, podr\u00edamos considerar las teselas vectoriales como un nuevo formato de \"imagen\". Igual que tenemos image/jpeg o image/png , podr\u00edamos inclu\u00edr un nuevo tipo MIME en las capabilities de nuestros servicios WMS y WMTS que sirviera los datos codificados en MVT. Esto es precisamente lo que hace la extensi\u00f3n Vector Tiles de GeoServer cuando define el nuevo tipo MIME: 1 application/x-protobuf;type=mapbox-vector","title":"Integraci\u00f3n de las teselas vectoriales con servicios est\u00e1ndar OGC"},{"location":"04_OGC/#caso-practico-la-extension-vector-tiles-de-geoserver","text":"Entrar en http://demo.fonts.cat/geoserver/ Explorar el GetCapabilities del servicio WMS. Buscar c\u00f3mo est\u00e1n anunciadas las capas de teselas vectoriales. Explorar las Capabilities de los servicios WMTS, TMS y WMS-C, y comprobar si existen capas de teselas vectoriales. Entrar como administrador, y observar c\u00f3mo est\u00e1 configurado GeoWebCach\u00e9 para las capas que sirven teselas vectoriales. Discutir ventajas y limitaciones de GeoServer.","title":"Caso pr\u00e1ctico: La extensi\u00f3n Vector Tiles de GeoServer"},{"location":"04_OGC/#ejemplos-de-integracion-con-otros-servicios-de-ogc","text":"","title":"Ejemplos de integraci\u00f3n con otros servicios de OGC"},{"location":"04_OGC/#wms","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 sources : { wms-source : { type : raster , tiles : [ http://www.ign.es/wms-inspire/pnoa-ma?bbox={bbox-epsg-3857 } format=image/jpeg service=WMS version= 1.1 . 1 request=GetMap srs=EPSG: 3857 width= 256 height= 256 layers=OI.OrthoimageCoverage ], tileSize : 256 } }, layers : [{ id : wms-layer , type : raster , source : wms-source }] DEMO WMS imagen","title":"WMS:"},{"location":"04_OGC/#wmts","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 sources : { wmts-source : { type : raster , tiles : [ http://www.ign.es/wmts/pnoa-ma?Layer=OI.OrthoimageCoverage Style=default TileMatrixSet=GoogleMapsCompatible Service=WMTS Request=GetTile Version=1.0.0 Format=image/jpeg TileMatrix={z } TileCol= { x } TileRow= { y } ], tileSize : 256 } }, layers : [{ id : wmts-layer , type : raster , source : wmts-source }] DEMO WMTS imagen","title":"WMTS:"},{"location":"04_OGC/#wfs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sources : { geojson-source : { type : geojson , data : http://demo.fonts.cat/geoserver/wfs?SERVICE=WFS VERSION=1.1.0 REQUEST=GetFeature TYPENAME=TMB:LINIES_METRO outputFormat=json srsName=EPSG:4326 } }, layers : [{ id : geojson-layer , type : line , source : geojson-source , paint : { line-width : 5, line-color : [ concat , # , [ get , COLOR_LINIA ]] } } ] DEMO WMTS imagen + WFS GeoJSON","title":"WFS:"},{"location":"04_OGC/#teselas-vectoriales-como-tms","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sources : { vectortile-tms-source : { type : vector , tiles : [ http://demo.fonts.cat:8000/geoserver/gwc/service/tms/1.0.0/TMB%3ALINIES_METRO@EPSG%3A900913@pbf/{z } / { x } / { y } .pbf ], scheme : tms } }, layers : [{ id : vectortile-layer , type : line , source : vectortile-tms-source , source-layer : LINIES_METRO , paint : { line-width : 5, line-color : [ concat , # , [ get , COLOR_LINIA ]] } } ] DEMO WMTS imagen + Vector Tile TMS","title":"Teselas Vectoriales como TMS:"},{"location":"05_sprites_glyphs/","text":"Iconos y tipograf\u00edas Sprites (iconos) Definici\u00f3n Un sprite es una imagen individual que contiene todos los iconos incluidos en un estilo. Al combinar muchas im\u00e1genes peque\u00f1as en una sola imagen (sprite), se puede reducir el n\u00famero de solicitudes necesarias para recuperar todas las im\u00e1genes, mejorar el rendimiento y hacer que el mapa sea m\u00e1s r\u00e1pido. Los Sprites pueden tener un tama\u00f1o m\u00e1ximo de 1024x1024 p\u00edxeles (o 2048x2048 para pantallas con alta DPI). Cada sprite viene acompa\u00f1ado de un archivo JSON donde se define el nombre de cada icono, y su posici\u00f3n y tama\u00f1o para saber c\u00f3mo \"recortarlo\" de la imagen com\u00fan. M\u00e1s informaci\u00f3n en sobre sprites https://www.mapbox.com/help/define-sprite/ Cada uno de los iconos contenidos en un sprite se puede usar como textura para el fondo del mapa, patr\u00f3n de relleno para un pol\u00edgono, patr\u00f3n de dibujo para una l\u00ednea, o una imagen de icono (s\u00edmbolo puntual). La propiedad sprite de un estilo apunta a una URL incompleta , a partir de la cual se pueden encontrar los diferentes ficheros (sprites y json complementario). Por ejemplo, si en el style.json se indica: 1 2 3 4 { ... sprite : http://tileserver.fonts.cat/styles/dark-matter/sprite } En realidad dicha URL no existe. Pero s\u00ed existen los siguientes recursos (a\u00f1adiendo .png , .json , @2x.png y @2x.json respectivamente): http://tileserver.fonts.cat/styles/dark-matter/sprite.png Sprite a resoluci\u00f3n convencional http://tileserver.fonts.cat/styles/dark-matter/sprite.json JSON que define cada icono dentro del sprite http://tileserver.fonts.cat/styles/dark-matter/sprite@2x.png Sprite a resoluci\u00f3n doble (para pantallas Retina) http://tileserver.fonts.cat/styles/dark-matter/sprite@2x.json JSON que define cada icono dentro del sprite de resoluci\u00f3n doble Ejemplo de sprite: Uno de los elementos definidos en el JSON: 1 2 3 4 5 6 7 8 9 10 11 { ... airport_11 : { height : 17 , width : 17 , x : 17 , y : 0 , pixelRatio : 1 }, .... } Caso pr\u00e1ctico: C\u00f3mo crear sprites propios Para generar los sprites a partir de im\u00e1genes individuales hay que crear los cuatro archivos. Esto se podr\u00eda hacer manualmente con un editor de texto, un editor de im\u00e1genes y mucha paciencia, pero afortunadamente existen herramientas que lo automatizan. Los sprites convencionales para la web difieren de los de Mapbox, ya que utilizan una imagen compuesta png y un archivo css con las reglas de simbolizaci\u00f3n para su aprovechamiento en p\u00e1ginas web. Mapbox GL, en cambio, necesita el fichero json , no un CSS. Para generar los sprites y sus json a partir de una colecci\u00f3n de im\u00e1genes en formato SVG, se recomienda el uso de la librer\u00eda de Mapbox spritezero-cli . A partir de los iconos SVG contenidos en https://github.com/geomatico/taller-vt-jiide/tree/master/ejercicios/05 Instalar spritezero (necesita node y npm): 1 npm install -g @mapbox/spritezero-cli Ejecutar spritezero para generar los iconos a resoluci\u00f3n est\u00e1ndar y a alta resoluci\u00f3n: 1 2 spritezero sprite icons spritezero -- retina sprite @2 x icons Una vez generados, los publicamos en la red para poder acceder a ellos desde nuestros estilos. Glyphs (tipograf\u00edas) En la propiedad glyphs de un estilo se indica una plantilla de URL para cargar tipograf\u00edas codificadas en PBF (el formato es distinto que MVT, ya que el .proto utilizado es distinto), que se usar\u00e1n para dibujar textos en el mapa. Por ejemplo: 1 2 3 4 { ... glyphs : http://tileserver.fonts.cat/fonts/{fontstack}/{range}.pbf } Esta plantilla de URL debe incluir dos tokens: {fontstack} es el nombre de la tipograf\u00eda. Por ejemplo Open Sans Bold . {range} es un rango de 256 puntos de c\u00f3digo Unicode (es decir, un subconjunto de letras o s\u00edmbolos). En funci\u00f3n del texto a mostrar, el visor solicitar\u00e1 los rangos necesarios. El primero es 0-255 . Una petici\u00f3n real tendr\u00eda la forma: http://tileserver.fonts.cat/fonts/Open%20Sans%20Bold/0-255.pbf Un glyph contiene una derivada de la tipograf\u00eda binaria llamada signed distance field que permite escalarla sin el pixelado. Una composici\u00f3n de varios glyphs dar\u00eda una imagen con este aspecto: Caso pr\u00e1ctico: C\u00f3mo crear glyphs propios Descargar el proyecto de github openmaptiles/fonts : 1 2 3 4 5 wget https://github.com/openmaptiles/fonts/archive/master.zip unzip master.zip cd fonts-master npm install node generate.js Al cabo de un rato, podemos ver los resultados en el directorio _output . Si no queremos generar una tipograf\u00eda determinada, basta con borrar el directorio que la contiene. Del mismo modo podemos a\u00f1adir tipograf\u00edas a\u00f1adiendo nuevos directorios y copiando dentro las tipograf\u00edas en formato TTF. El directorio _output no se borra entre ejecuciones, con lo que habremos conservado todas las fuentes anteriores, adem\u00e1s de la reci\u00e9n generada \"Comic Sans\". Finalmente, debemos publicar el contenido de _output en un servidor web, para que los visores de mapbox puedan acceder a \u00e9l.","title":"5. Iconos y tipograf\u00edas"},{"location":"05_sprites_glyphs/#iconos-y-tipografias","text":"","title":"Iconos y tipograf\u00edas"},{"location":"05_sprites_glyphs/#sprites-iconos","text":"Definici\u00f3n Un sprite es una imagen individual que contiene todos los iconos incluidos en un estilo. Al combinar muchas im\u00e1genes peque\u00f1as en una sola imagen (sprite), se puede reducir el n\u00famero de solicitudes necesarias para recuperar todas las im\u00e1genes, mejorar el rendimiento y hacer que el mapa sea m\u00e1s r\u00e1pido. Los Sprites pueden tener un tama\u00f1o m\u00e1ximo de 1024x1024 p\u00edxeles (o 2048x2048 para pantallas con alta DPI). Cada sprite viene acompa\u00f1ado de un archivo JSON donde se define el nombre de cada icono, y su posici\u00f3n y tama\u00f1o para saber c\u00f3mo \"recortarlo\" de la imagen com\u00fan. M\u00e1s informaci\u00f3n en sobre sprites https://www.mapbox.com/help/define-sprite/ Cada uno de los iconos contenidos en un sprite se puede usar como textura para el fondo del mapa, patr\u00f3n de relleno para un pol\u00edgono, patr\u00f3n de dibujo para una l\u00ednea, o una imagen de icono (s\u00edmbolo puntual). La propiedad sprite de un estilo apunta a una URL incompleta , a partir de la cual se pueden encontrar los diferentes ficheros (sprites y json complementario). Por ejemplo, si en el style.json se indica: 1 2 3 4 { ... sprite : http://tileserver.fonts.cat/styles/dark-matter/sprite } En realidad dicha URL no existe. Pero s\u00ed existen los siguientes recursos (a\u00f1adiendo .png , .json , @2x.png y @2x.json respectivamente): http://tileserver.fonts.cat/styles/dark-matter/sprite.png Sprite a resoluci\u00f3n convencional http://tileserver.fonts.cat/styles/dark-matter/sprite.json JSON que define cada icono dentro del sprite http://tileserver.fonts.cat/styles/dark-matter/sprite@2x.png Sprite a resoluci\u00f3n doble (para pantallas Retina) http://tileserver.fonts.cat/styles/dark-matter/sprite@2x.json JSON que define cada icono dentro del sprite de resoluci\u00f3n doble Ejemplo de sprite: Uno de los elementos definidos en el JSON: 1 2 3 4 5 6 7 8 9 10 11 { ... airport_11 : { height : 17 , width : 17 , x : 17 , y : 0 , pixelRatio : 1 }, .... }","title":"Sprites (iconos)"},{"location":"05_sprites_glyphs/#caso-practico-como-crear-sprites-propios","text":"Para generar los sprites a partir de im\u00e1genes individuales hay que crear los cuatro archivos. Esto se podr\u00eda hacer manualmente con un editor de texto, un editor de im\u00e1genes y mucha paciencia, pero afortunadamente existen herramientas que lo automatizan. Los sprites convencionales para la web difieren de los de Mapbox, ya que utilizan una imagen compuesta png y un archivo css con las reglas de simbolizaci\u00f3n para su aprovechamiento en p\u00e1ginas web. Mapbox GL, en cambio, necesita el fichero json , no un CSS. Para generar los sprites y sus json a partir de una colecci\u00f3n de im\u00e1genes en formato SVG, se recomienda el uso de la librer\u00eda de Mapbox spritezero-cli . A partir de los iconos SVG contenidos en https://github.com/geomatico/taller-vt-jiide/tree/master/ejercicios/05 Instalar spritezero (necesita node y npm): 1 npm install -g @mapbox/spritezero-cli Ejecutar spritezero para generar los iconos a resoluci\u00f3n est\u00e1ndar y a alta resoluci\u00f3n: 1 2 spritezero sprite icons spritezero -- retina sprite @2 x icons Una vez generados, los publicamos en la red para poder acceder a ellos desde nuestros estilos.","title":"Caso pr\u00e1ctico: C\u00f3mo crear sprites propios"},{"location":"05_sprites_glyphs/#glyphs-tipografias","text":"En la propiedad glyphs de un estilo se indica una plantilla de URL para cargar tipograf\u00edas codificadas en PBF (el formato es distinto que MVT, ya que el .proto utilizado es distinto), que se usar\u00e1n para dibujar textos en el mapa. Por ejemplo: 1 2 3 4 { ... glyphs : http://tileserver.fonts.cat/fonts/{fontstack}/{range}.pbf } Esta plantilla de URL debe incluir dos tokens: {fontstack} es el nombre de la tipograf\u00eda. Por ejemplo Open Sans Bold . {range} es un rango de 256 puntos de c\u00f3digo Unicode (es decir, un subconjunto de letras o s\u00edmbolos). En funci\u00f3n del texto a mostrar, el visor solicitar\u00e1 los rangos necesarios. El primero es 0-255 . Una petici\u00f3n real tendr\u00eda la forma: http://tileserver.fonts.cat/fonts/Open%20Sans%20Bold/0-255.pbf Un glyph contiene una derivada de la tipograf\u00eda binaria llamada signed distance field que permite escalarla sin el pixelado. Una composici\u00f3n de varios glyphs dar\u00eda una imagen con este aspecto:","title":"Glyphs (tipograf\u00edas)"},{"location":"05_sprites_glyphs/#caso-practico-como-crear-glyphs-propios","text":"Descargar el proyecto de github openmaptiles/fonts : 1 2 3 4 5 wget https://github.com/openmaptiles/fonts/archive/master.zip unzip master.zip cd fonts-master npm install node generate.js Al cabo de un rato, podemos ver los resultados en el directorio _output . Si no queremos generar una tipograf\u00eda determinada, basta con borrar el directorio que la contiene. Del mismo modo podemos a\u00f1adir tipograf\u00edas a\u00f1adiendo nuevos directorios y copiando dentro las tipograf\u00edas en formato TTF. El directorio _output no se borra entre ejecuciones, con lo que habremos conservado todas las fuentes anteriores, adem\u00e1s de la reci\u00e9n generada \"Comic Sans\". Finalmente, debemos publicar el contenido de _output en un servidor web, para que los visores de mapbox puedan acceder a \u00e9l.","title":"Caso pr\u00e1ctico: C\u00f3mo crear glyphs propios"},{"location":"06_estilos/","text":"Especificaci\u00f3n de estilo [Caso pr\u00e1ctico: maputnik]","title":"6. C\u00f3mo simbolizarlas"},{"location":"06_estilos/#especificacion-de-estilo","text":"[Caso pr\u00e1ctico: maputnik]","title":"Especificaci\u00f3n de estilo"},{"location":"07_visores/","text":"Visor Mapbox GL JS: Menorca Online http://geomati.co/taller-vt-jiide/ejemplos/menorca-online.html","title":"7. C\u00f3mo visualizarlas"},{"location":"07_visores/#visor-mapbox-gl-js-menorca-online","text":"http://geomati.co/taller-vt-jiide/ejemplos/menorca-online.html","title":"Visor Mapbox GL JS: Menorca Online"},{"location":"08_recursos/","text":"Recursos adicionales Versi\u00f3n ampliada del taller Versi\u00f3n completa del taller, de 4 horas, donde se entra m\u00e1s en detalle en cada etapa, poniendo en marcha nuestros propios servidores: https://geoinquiets.github.io/taller-vt/ Versi\u00f3n reducida del taller Presentaci\u00f3n de car\u00e1cter muy pr\u00e1ctico: Publicar datos y crear visores sin instalar nada, haciendo uso de los servicios de MapBox: https://geoinquiets.github.io/vt-hackato-atm/ Documentaci\u00f3n oficial Mapbox GL La web de referencia tiene 4 pesta\u00f1as. Os estar\u00e9is moviendo entre las dos primeras, que contienen enlaces hacia los ejemplos de la tercera: API: https://www.mapbox.com/mapbox-gl-js/api/ Style Spec: https://www.mapbox.com/mapbox-gl-js/style-spec Examples: https://www.mapbox.com/mapbox-gl-js/example/simple-map/ Plugis: https://www.mapbox.com/mapbox-gl-js/plugins Otros enlaces Mayormente de Raf , nuestra fuente diaria de vitaminas, v\u00eda @geoinquiets . Awesome Vector Tiles Natural Earth Vector Tiles by Lukas Martinelli Tutorial de los Geoinquietos de Londres Tilemaker, de OSM a mbtiles de una tacada Qu\u00e9 son las teselas vectoriales (vector tiles) y c\u00f3mo generarlos con PostGIS / GeoServer Natural Earth Quickstart Style implemented with Tegola GeoServer MBStyle Cookbook GeoServer MBStyle Styling Workbook","title":"8. Recursos"},{"location":"08_recursos/#recursos-adicionales","text":"","title":"Recursos adicionales"},{"location":"08_recursos/#version-ampliada-del-taller","text":"Versi\u00f3n completa del taller, de 4 horas, donde se entra m\u00e1s en detalle en cada etapa, poniendo en marcha nuestros propios servidores: https://geoinquiets.github.io/taller-vt/","title":"Versi\u00f3n ampliada del taller"},{"location":"08_recursos/#version-reducida-del-taller","text":"Presentaci\u00f3n de car\u00e1cter muy pr\u00e1ctico: Publicar datos y crear visores sin instalar nada, haciendo uso de los servicios de MapBox: https://geoinquiets.github.io/vt-hackato-atm/","title":"Versi\u00f3n reducida del taller"},{"location":"08_recursos/#documentacion-oficial-mapbox-gl","text":"La web de referencia tiene 4 pesta\u00f1as. Os estar\u00e9is moviendo entre las dos primeras, que contienen enlaces hacia los ejemplos de la tercera: API: https://www.mapbox.com/mapbox-gl-js/api/ Style Spec: https://www.mapbox.com/mapbox-gl-js/style-spec Examples: https://www.mapbox.com/mapbox-gl-js/example/simple-map/ Plugis: https://www.mapbox.com/mapbox-gl-js/plugins","title":"Documentaci\u00f3n oficial Mapbox GL"},{"location":"08_recursos/#otros-enlaces","text":"Mayormente de Raf , nuestra fuente diaria de vitaminas, v\u00eda @geoinquiets . Awesome Vector Tiles Natural Earth Vector Tiles by Lukas Martinelli Tutorial de los Geoinquietos de Londres Tilemaker, de OSM a mbtiles de una tacada Qu\u00e9 son las teselas vectoriales (vector tiles) y c\u00f3mo generarlos con PostGIS / GeoServer Natural Earth Quickstart Style implemented with Tegola GeoServer MBStyle Cookbook GeoServer MBStyle Styling Workbook","title":"Otros enlaces"},{"location":"1_teoria/","text":"Qu\u00e9 son las teselas vectoriales Presentaci\u00f3n Ver este cap\u00edtulo en formato presentaci\u00f3n Las teselas vectoriales son un formato de datos liviano para almacenar datos vectoriales geoespaciales, como puntos, l\u00edneas y pol\u00edgonos. Las teselas vectoriales codifican informaci\u00f3n geogr\u00e1fica de acuerdo con la especificaci\u00f3n de teselas vector de Mapbox. La especificaci\u00f3n de Mapbox es un est\u00e1ndar abierto bajo una licencia Creative Commons Attribution 3.0 US. Una tesela vectorial (vector tiles) contiene datos vectoriales georreferenciados (puede contener m\u00faltiples capas), recortados en teselas para facilitar su recuperaci\u00f3n. Son equivalentes a las teselas raster tradicionales (WMTS, TMS) pero retornan datos vectoriales en lugar de una imagen. Cada conjunto de teselas vectoriales tiene su propio esquema. Un esquema consiste en nombres de capas, atributos, selecci\u00f3n de elementos, etc. No existe un esquema que sirva para todo. Existen varios esquemas como por ejemplo: OpenMapTiles, Mapbox Streets, etc. Warning Las teselas vectoriales no son un formato de datos vectoriales estilo Shapefile, GeoJSON, etc. pensado para trabajar (hacer an\u00e1lisis, explotaci\u00f3n de datos, etc.) sino que est\u00e1 pensado y enfocado principalmente en la visualizaci\u00f3n. Un poco de Historia Fechas destacadas 1966 Sistema de Informaci\u00f3n Geogr\u00e1fica de Canad\u00e1 (CGIS) utiliza \u201cmarco\u201d para almacenar informaci\u00f3n 1975 Servicio de Vida Silvestre EE.UU. utiliza \u201cgeounit\u201d para almacenar datos Finales de 1980 teselas se vuelven \u201cinvisibles\u201d para el usuario final. Manejo de datos continuo Abril 2014 Mapbox saca la version 1.0 de la especificaci\u00f3n Mapbox Vector Tile Existe una larga historia de uso de teselas vectoriales en SIG. En 1966 el Sistema de Informaci\u00f3n Geogr\u00e1fica de Canad\u00e1 (CGIS), utilizaba un esquema de almacenamiento vectorial que permit\u00eda a las computadoras de recursos limitados acceder de manera eficiente y procesar datos de mapas vectoriales. CGIS us\u00f3 el t\u00e9rmino \"marco\" en lugar de teselas vectoriales. En 1975, el Servicio de Vida Silvestre de los EE.UU. inici\u00f3 un programa nacional para mapear y digitalizar todos los humedales de los EE.UU. En 1976 desarrollan un software que se llam\u00f3 WAMS (Wetlands Analytical Mapping System). El almacenage de datos del WAMS usaba una estructura de teselas vectorial. Cada tesela se llamaba \"geounit\". Una geounit correspond\u00eda a una de las escalas cuadrangulares del USGS, generalmente 1:24000. En 1986 bas\u00e1ndose en la experiencia operativa adquirida en la implementaci\u00f3n y el uso de WAMS y del Map Overlay and Statistical System (MOSS), se lanz\u00f3 un SIG comercial DeltaMap (m\u00e1s tarde GenaMap) basado en UNIX que implement\u00f3 una estructura mejorada de almacenamiento y acceso de teselas vectores. DeltaMap permiti\u00f3 al usuario definir cualquier tama\u00f1o de tesela en cualquier sistema de referencia de coordenadas (CRS). De esta forma, los datos dispersos requer\u00edan solo unas pocas teselas, mientras que los datos densos pod\u00edan usar teselas mucho m\u00e1s peque\u00f1as. Utilizaban R-trees como el esquema de indexaci\u00f3n para las teselas de vectores. A finales de la d\u00e9cada de 1980, se mejor\u00f3 a\u00fan m\u00e1s GenaMap para permitir el procesamiento \"continuo e ininterrumpido\" de las capas de teselas. B\u00e1sicamente, desde la perspectiva del usuario final, las teselas se volvieron invisibles. [^1] [^1] https://en.wikipedia.org/wiki/Vector_tiles Abril de 2014 Mapbox saca la version 1.0 de la especificaci\u00f3n Mapbox Vector Tile (MVT). Diciembre 2015 versi\u00f3n 2.0 de la especificaci\u00f3n MVT. Marzo de 2015 ESRI (el que no debe ser nombrado) anuncia que soportar\u00e1 MVT. Mapbox actualmente est\u00e1 trabajando en la versi\u00f3n 3. Diferencias entre teselas raster y teselas vectoriales Teselas vectoriales Teselas raster Estilo se define en el cliente Estilo se define en el servidor S\u00f3lo se necesita teselar la informaci\u00f3n una sola vez y se pueden tener m\u00faltiples mapas Hay que teselas la informaci\u00f3n para cada mapa Overzoom se mantiene resoluci\u00f3n Overzoom pierde resoluci\u00f3n (pixelado) Menor tama\u00f1o (se recomienda m\u00e1ximo 500kb) M\u00e1s f\u00e1ciles de consumir Cache ocupa mucho menos espacio. F\u00e1ctible el uso en dispositivos m\u00f3viles sin conexi\u00f3n Cache ocupa mucho espacio. Uso en dispositivos m\u00f3viles requiere mucho espacio de disco Acceso nativo a la informaci\u00f3n del objeto (atributos y geometr\u00eda), lo que permite un procesamiento muy sofisticado Se ven mejor en dispositivos de alta resoluci\u00f3n Comparativa pesos teselas vector vs raster. Fuente https://plot.ly/~mourner/118.embed Comparaci\u00f3n con otros formatos Teselas Vectoriales WMS WMTS WFS Nivel de zoom continuo Nivel de zoom continuo Nivel de zoom discreto Nivel de zoom continuo Teselado No teselado, con lo cual no hay problemas de etiquetas Teselado No teselado Retorna datos en vector modificados (generalizados, simplificados) Retorna imagen raster Retorna imagen raster Retorna datos en vector sin modificar Cache tanto en cliente como en servidor No cache Cache tanto en cliente como en servidor No cache Escalabilidad Escalabilidad Interactivo No interactivo (se pueden hacer consultas getFeatureInfo) No interactivo Interactivo Estilo flexible (cliente es quien define el estilo) Estilo fijo (se puede modificar via SLD pero lo renderiza el servidor) Estilo fijo (definido en el servidor) Estilo flexible Impresi\u00f3n Hi-DPI Impresi\u00f3n problemas con Hi-DPI Dif\u00edcil impresi\u00f3n (montar el mosaico de im\u00e1ges y problemas con Hi-DPI) Impresi\u00f3n Hi-DPI C\u00f3mo est\u00e1n hechas por dentro Las geometr\u00edas y los atributos se codifican como datos binarios de Google Protobuf (PBF). Codificar geometr\u00edas Para codificar informaci\u00f3n geogr\u00e1fica en una tesela vectorial, una herramienta debe convertir las coordenadas geogr\u00e1ficas, como la latitud y la longitud, en coordenadas vectoriales de cuadr\u00edculas. Las teselas de vectoriales no tienen ning\u00fan concepto de informaci\u00f3n geogr\u00e1fica. Codifican puntos, l\u00edneas y pol\u00edgonos como pares x/y relativos a la esquina superior izquierda de la cuadr\u00edcula de forma descendente. Las geometr\u00edas son transformadas a una sola tesela, con un sistema de coordenadas de p\u00edxel local, que por defecto va de la esquina superior izquierda (0,0) a la esquina inferior derecha (4096,4096). Codificar geometr\u00eda. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-geom Codificar atributos Los atributos se codifican como un conjunto \u00fanico de claves (algo as\u00ed como un esquema de campos de capa) y la lista de sus valores. Los atributos est\u00e1n codificados en una serie de etiquetas que existen dentro de un elemento en el vector que tienen valores enteros que hacen referencia a las claves y los valores que provienen de la geometr\u00eda. Esto elimina la redundancia de los atributos para geometr\u00edas que tienen las mismas claves y valores similares. Codificar atributos. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-attr Winding order El Winding order (direcci\u00f3n de digitalizaci\u00f3n) se refiere a la direcci\u00f3n en que se dibuja un anillo en un mosaico vectorial, ya sea en sentido horario o antihorario. Muchas geometr\u00edas son multipol\u00edgonos con \"agujeros\", que tambi\u00e9n se representan como anillos de pol\u00edgono. Es importante poder inferir el orden al extraer datos fuente de un mosaico vectorial y comprender si la geometr\u00eda es parte de un pol\u00edgono m\u00faltiple o un pol\u00edgono \u00fanico. Para que los procesadores distingan de manera apropiada que pol\u00edgonos son agujeros y cu\u00e1les son geometr\u00edas \u00fanicas, la especificaci\u00f3n requiere que todos los pol\u00edgonos sean v\u00e1lidos (validez de OGC). Cualquier anillo interior poligonal debe orientarse con el orden opuesto al de su anillo exterior principal y todos los anillos interiores deben seguir directamente el anillo exterior al que pertenecen. Los anillos exteriores deben estar orientados en el sentido de las agujas del reloj y los anillos interiores deben estar orientados en sentido contrario a las agujas del reloj. Winding order. Fuente https://www.mapbox.com/vector-tiles/specification/#winding-order Diferentes especificaciones y conceptos relacionados con las teselas vectoriales pbf Protocol buffers desarrollado por Google (para uso interno) es un m\u00e9todo para serializar datos estructurados. Es language-neutral , platform-neutral y en cuyo objetivo de dise\u00f1o enfatizaron la simplicidad y el rendimiento. El m\u00e9todo implica un lenguaje de descripci\u00f3n de interfaz que describe la estructura de algunos datos y un programa que genera c\u00f3digo fuente a partir de esa descripci\u00f3n para generar o analizar una secuencia de bytes que representa los datos estructurados. mvt Formato binario basado en la especificaci\u00f3n de Mapbox que usa pbf para serializar datos geogr\u00e1ficos. Los archivos deber\u00edan tener extensi\u00f3n .mvt pero no es obligatorio as\u00ed que se pueden encontrar archivos con extensi\u00f3n .pbf, .vector.pbf o .mvt.gz (compresi\u00f3n gzip) Por ejemplo un conjunto de teselas mvt almacenadas en un SQLite siguiendo una esquema espec\u00edfico formar\u00eda un MBTiles. MBTiles MBTiles es un formato de archivo para almacenar conjuntos de teselas. Est\u00e1 dise\u00f1ado para que pueda empaquetar los potencialmente miles de archivos que componen un conjunto de teselas y moverlos, usarlos en una aplicaci\u00f3n web o m\u00f3vil. MBTiles es una especificaci\u00f3n abierta y se basa en la base de datos SQLite. MBTiles puede contener conjunto de teselas reaster y/o vector. MBTiles es una especificaci\u00f3n compacta y restrictiva. S\u00f3lo admite datos teselados, incluidas teselas vectoriales o de im\u00e1genes y UTFGrid (hasta la versi\u00f3n 1.2). S\u00f3lo la proyecci\u00f3n esf\u00e9rica de Mercator es soportada para la presentaci\u00f3n (visualizaci\u00f3n) y s\u00f3lo se admiten coordenadas de latitud y longitud para metadatos, como l\u00edmites y centros. Es una especificaci\u00f3n m\u00ednima, que sol\u00f3 especifica las formas en que los datos deben ser recuperables. Por lo tanto, los archivos MBTiles pueden comprimir y optimizar datos internamente, y construir vistas que se adhieren a la especificaci\u00f3n MBTiles. Dentro del MBtiles los vectores estan almacenados comprimidos (gzip) y en formato pbf. A diferencia de Spatialite, GeoJSON y Rasterlite, MBTiles no es un almacenamiento de datos sin formato. Es almacenamiento de datos en teselas. tilejson TileJSON es un formato para describir un conjunto de teselas. Realiza un seguimiento de d\u00f3nde solicitar el conjunto de teselas, el nombre del conjunto de teselas y cualquier atribuci\u00f3n que sea necesaria al utilizar el conjunto de teselas. Esta especificaci\u00f3n intenta crear un est\u00e1ndar para representar metadatos sobre m\u00faltiples tipos de capas, para ayudar a los clientes en la configuraci\u00f3n y navegaci\u00f3n. Overzoom Overzooming es una t\u00e9cnica espec\u00edfica de teselas vectorial que permite que una tesela se represente m\u00e1s all\u00e1 de su nivel de zoom previsto, por lo que contin\u00faa siendo visible en el mapa. Si un conjunto de teselas tiene un minzoom de 6 y un maxzoom de 12, esos son los rangos v\u00e1lidos calculados por el generador de teselas. Si ampliara el mapa m\u00e1s all\u00e1 del nivel de zoom 12, el renderizador del mapa puede seguir utilizando los datos del zoom 12 escalando los datos del vector hacia arriba. Esto, por supuesto, puede dar lugar a grandes simplificaciones de datos si las geometr\u00edas se representan demasiado por encima de su nivel real de detalle. Las teselas raster pierden claridad si ocurre overzoom. Por ejemplo, si est\u00e1 visualizando un conjunto de teselas raster con una extensi\u00f3n de zoom entre z0 y z6, si hace un zoom a un nivel de zoom m\u00e1s alto despu\u00e9s de z6, las im\u00e1genes se volver\u00e1n borrosas y dif\u00edciles de ver. Los efectos del overzoom no son tan notables con las teselas vector, ya que los datos vectoriales no se almacenan en un formato basado en p\u00edxeles, sino que se codifican y calculan a partir de una serie de puntos, l\u00edneas y pol\u00edgonos. Overzoom nivel zoom 16 vs nivel zoom 19. Presentaci\u00f3n de ejemplos visuales hechos con vt Terreno https://openicgc.github.io/ Luces LA Edificios con m\u00fasica https://codepen.io/jwhazel/pen/NYzpWG blog explicativo https://medium.com/@erdag/mappox-mapmadness18-round-4-1251a8c10421 Tem\u00e1tico filtro Filtrado al vuelo Mapa de calor Esquema general de lo que se va a hacer en el taller Esquema taller","title":"Qu\u00e9 son las teselas vectoriales"},{"location":"1_teoria/#que-son-las-teselas-vectoriales","text":"Presentaci\u00f3n Ver este cap\u00edtulo en formato presentaci\u00f3n Las teselas vectoriales son un formato de datos liviano para almacenar datos vectoriales geoespaciales, como puntos, l\u00edneas y pol\u00edgonos. Las teselas vectoriales codifican informaci\u00f3n geogr\u00e1fica de acuerdo con la especificaci\u00f3n de teselas vector de Mapbox. La especificaci\u00f3n de Mapbox es un est\u00e1ndar abierto bajo una licencia Creative Commons Attribution 3.0 US. Una tesela vectorial (vector tiles) contiene datos vectoriales georreferenciados (puede contener m\u00faltiples capas), recortados en teselas para facilitar su recuperaci\u00f3n. Son equivalentes a las teselas raster tradicionales (WMTS, TMS) pero retornan datos vectoriales en lugar de una imagen. Cada conjunto de teselas vectoriales tiene su propio esquema. Un esquema consiste en nombres de capas, atributos, selecci\u00f3n de elementos, etc. No existe un esquema que sirva para todo. Existen varios esquemas como por ejemplo: OpenMapTiles, Mapbox Streets, etc. Warning Las teselas vectoriales no son un formato de datos vectoriales estilo Shapefile, GeoJSON, etc. pensado para trabajar (hacer an\u00e1lisis, explotaci\u00f3n de datos, etc.) sino que est\u00e1 pensado y enfocado principalmente en la visualizaci\u00f3n.","title":"Qu\u00e9 son las teselas vectoriales"},{"location":"1_teoria/#un-poco-de-historia","text":"Fechas destacadas 1966 Sistema de Informaci\u00f3n Geogr\u00e1fica de Canad\u00e1 (CGIS) utiliza \u201cmarco\u201d para almacenar informaci\u00f3n 1975 Servicio de Vida Silvestre EE.UU. utiliza \u201cgeounit\u201d para almacenar datos Finales de 1980 teselas se vuelven \u201cinvisibles\u201d para el usuario final. Manejo de datos continuo Abril 2014 Mapbox saca la version 1.0 de la especificaci\u00f3n Mapbox Vector Tile Existe una larga historia de uso de teselas vectoriales en SIG. En 1966 el Sistema de Informaci\u00f3n Geogr\u00e1fica de Canad\u00e1 (CGIS), utilizaba un esquema de almacenamiento vectorial que permit\u00eda a las computadoras de recursos limitados acceder de manera eficiente y procesar datos de mapas vectoriales. CGIS us\u00f3 el t\u00e9rmino \"marco\" en lugar de teselas vectoriales. En 1975, el Servicio de Vida Silvestre de los EE.UU. inici\u00f3 un programa nacional para mapear y digitalizar todos los humedales de los EE.UU. En 1976 desarrollan un software que se llam\u00f3 WAMS (Wetlands Analytical Mapping System). El almacenage de datos del WAMS usaba una estructura de teselas vectorial. Cada tesela se llamaba \"geounit\". Una geounit correspond\u00eda a una de las escalas cuadrangulares del USGS, generalmente 1:24000. En 1986 bas\u00e1ndose en la experiencia operativa adquirida en la implementaci\u00f3n y el uso de WAMS y del Map Overlay and Statistical System (MOSS), se lanz\u00f3 un SIG comercial DeltaMap (m\u00e1s tarde GenaMap) basado en UNIX que implement\u00f3 una estructura mejorada de almacenamiento y acceso de teselas vectores. DeltaMap permiti\u00f3 al usuario definir cualquier tama\u00f1o de tesela en cualquier sistema de referencia de coordenadas (CRS). De esta forma, los datos dispersos requer\u00edan solo unas pocas teselas, mientras que los datos densos pod\u00edan usar teselas mucho m\u00e1s peque\u00f1as. Utilizaban R-trees como el esquema de indexaci\u00f3n para las teselas de vectores. A finales de la d\u00e9cada de 1980, se mejor\u00f3 a\u00fan m\u00e1s GenaMap para permitir el procesamiento \"continuo e ininterrumpido\" de las capas de teselas. B\u00e1sicamente, desde la perspectiva del usuario final, las teselas se volvieron invisibles. [^1] [^1] https://en.wikipedia.org/wiki/Vector_tiles Abril de 2014 Mapbox saca la version 1.0 de la especificaci\u00f3n Mapbox Vector Tile (MVT). Diciembre 2015 versi\u00f3n 2.0 de la especificaci\u00f3n MVT. Marzo de 2015 ESRI (el que no debe ser nombrado) anuncia que soportar\u00e1 MVT. Mapbox actualmente est\u00e1 trabajando en la versi\u00f3n 3.","title":"Un poco de Historia"},{"location":"1_teoria/#diferencias-entre-teselas-raster-y-teselas-vectoriales","text":"Teselas vectoriales Teselas raster Estilo se define en el cliente Estilo se define en el servidor S\u00f3lo se necesita teselar la informaci\u00f3n una sola vez y se pueden tener m\u00faltiples mapas Hay que teselas la informaci\u00f3n para cada mapa Overzoom se mantiene resoluci\u00f3n Overzoom pierde resoluci\u00f3n (pixelado) Menor tama\u00f1o (se recomienda m\u00e1ximo 500kb) M\u00e1s f\u00e1ciles de consumir Cache ocupa mucho menos espacio. F\u00e1ctible el uso en dispositivos m\u00f3viles sin conexi\u00f3n Cache ocupa mucho espacio. Uso en dispositivos m\u00f3viles requiere mucho espacio de disco Acceso nativo a la informaci\u00f3n del objeto (atributos y geometr\u00eda), lo que permite un procesamiento muy sofisticado Se ven mejor en dispositivos de alta resoluci\u00f3n Comparativa pesos teselas vector vs raster. Fuente https://plot.ly/~mourner/118.embed","title":"Diferencias entre teselas raster y teselas vectoriales"},{"location":"1_teoria/#comparacion-con-otros-formatos","text":"Teselas Vectoriales WMS WMTS WFS Nivel de zoom continuo Nivel de zoom continuo Nivel de zoom discreto Nivel de zoom continuo Teselado No teselado, con lo cual no hay problemas de etiquetas Teselado No teselado Retorna datos en vector modificados (generalizados, simplificados) Retorna imagen raster Retorna imagen raster Retorna datos en vector sin modificar Cache tanto en cliente como en servidor No cache Cache tanto en cliente como en servidor No cache Escalabilidad Escalabilidad Interactivo No interactivo (se pueden hacer consultas getFeatureInfo) No interactivo Interactivo Estilo flexible (cliente es quien define el estilo) Estilo fijo (se puede modificar via SLD pero lo renderiza el servidor) Estilo fijo (definido en el servidor) Estilo flexible Impresi\u00f3n Hi-DPI Impresi\u00f3n problemas con Hi-DPI Dif\u00edcil impresi\u00f3n (montar el mosaico de im\u00e1ges y problemas con Hi-DPI) Impresi\u00f3n Hi-DPI","title":"Comparaci\u00f3n con otros formatos"},{"location":"1_teoria/#como-estan-hechas-por-dentro","text":"Las geometr\u00edas y los atributos se codifican como datos binarios de Google Protobuf (PBF).","title":"C\u00f3mo est\u00e1n hechas por dentro"},{"location":"1_teoria/#codificar-geometrias","text":"Para codificar informaci\u00f3n geogr\u00e1fica en una tesela vectorial, una herramienta debe convertir las coordenadas geogr\u00e1ficas, como la latitud y la longitud, en coordenadas vectoriales de cuadr\u00edculas. Las teselas de vectoriales no tienen ning\u00fan concepto de informaci\u00f3n geogr\u00e1fica. Codifican puntos, l\u00edneas y pol\u00edgonos como pares x/y relativos a la esquina superior izquierda de la cuadr\u00edcula de forma descendente. Las geometr\u00edas son transformadas a una sola tesela, con un sistema de coordenadas de p\u00edxel local, que por defecto va de la esquina superior izquierda (0,0) a la esquina inferior derecha (4096,4096). Codificar geometr\u00eda. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-geom","title":"Codificar geometr\u00edas"},{"location":"1_teoria/#codificar-atributos","text":"Los atributos se codifican como un conjunto \u00fanico de claves (algo as\u00ed como un esquema de campos de capa) y la lista de sus valores. Los atributos est\u00e1n codificados en una serie de etiquetas que existen dentro de un elemento en el vector que tienen valores enteros que hacen referencia a las claves y los valores que provienen de la geometr\u00eda. Esto elimina la redundancia de los atributos para geometr\u00edas que tienen las mismas claves y valores similares. Codificar atributos. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-attr","title":"Codificar atributos"},{"location":"1_teoria/#winding-order","text":"El Winding order (direcci\u00f3n de digitalizaci\u00f3n) se refiere a la direcci\u00f3n en que se dibuja un anillo en un mosaico vectorial, ya sea en sentido horario o antihorario. Muchas geometr\u00edas son multipol\u00edgonos con \"agujeros\", que tambi\u00e9n se representan como anillos de pol\u00edgono. Es importante poder inferir el orden al extraer datos fuente de un mosaico vectorial y comprender si la geometr\u00eda es parte de un pol\u00edgono m\u00faltiple o un pol\u00edgono \u00fanico. Para que los procesadores distingan de manera apropiada que pol\u00edgonos son agujeros y cu\u00e1les son geometr\u00edas \u00fanicas, la especificaci\u00f3n requiere que todos los pol\u00edgonos sean v\u00e1lidos (validez de OGC). Cualquier anillo interior poligonal debe orientarse con el orden opuesto al de su anillo exterior principal y todos los anillos interiores deben seguir directamente el anillo exterior al que pertenecen. Los anillos exteriores deben estar orientados en el sentido de las agujas del reloj y los anillos interiores deben estar orientados en sentido contrario a las agujas del reloj. Winding order. Fuente https://www.mapbox.com/vector-tiles/specification/#winding-order","title":"Winding order"},{"location":"1_teoria/#diferentes-especificaciones-y-conceptos-relacionados-con-las-teselas-vectoriales","text":"","title":"Diferentes especificaciones y conceptos relacionados con las teselas vectoriales"},{"location":"1_teoria/#pbf","text":"Protocol buffers desarrollado por Google (para uso interno) es un m\u00e9todo para serializar datos estructurados. Es language-neutral , platform-neutral y en cuyo objetivo de dise\u00f1o enfatizaron la simplicidad y el rendimiento. El m\u00e9todo implica un lenguaje de descripci\u00f3n de interfaz que describe la estructura de algunos datos y un programa que genera c\u00f3digo fuente a partir de esa descripci\u00f3n para generar o analizar una secuencia de bytes que representa los datos estructurados.","title":"pbf"},{"location":"1_teoria/#mvt","text":"Formato binario basado en la especificaci\u00f3n de Mapbox que usa pbf para serializar datos geogr\u00e1ficos. Los archivos deber\u00edan tener extensi\u00f3n .mvt pero no es obligatorio as\u00ed que se pueden encontrar archivos con extensi\u00f3n .pbf, .vector.pbf o .mvt.gz (compresi\u00f3n gzip) Por ejemplo un conjunto de teselas mvt almacenadas en un SQLite siguiendo una esquema espec\u00edfico formar\u00eda un MBTiles.","title":"mvt"},{"location":"1_teoria/#mbtiles","text":"MBTiles es un formato de archivo para almacenar conjuntos de teselas. Est\u00e1 dise\u00f1ado para que pueda empaquetar los potencialmente miles de archivos que componen un conjunto de teselas y moverlos, usarlos en una aplicaci\u00f3n web o m\u00f3vil. MBTiles es una especificaci\u00f3n abierta y se basa en la base de datos SQLite. MBTiles puede contener conjunto de teselas reaster y/o vector. MBTiles es una especificaci\u00f3n compacta y restrictiva. S\u00f3lo admite datos teselados, incluidas teselas vectoriales o de im\u00e1genes y UTFGrid (hasta la versi\u00f3n 1.2). S\u00f3lo la proyecci\u00f3n esf\u00e9rica de Mercator es soportada para la presentaci\u00f3n (visualizaci\u00f3n) y s\u00f3lo se admiten coordenadas de latitud y longitud para metadatos, como l\u00edmites y centros. Es una especificaci\u00f3n m\u00ednima, que sol\u00f3 especifica las formas en que los datos deben ser recuperables. Por lo tanto, los archivos MBTiles pueden comprimir y optimizar datos internamente, y construir vistas que se adhieren a la especificaci\u00f3n MBTiles. Dentro del MBtiles los vectores estan almacenados comprimidos (gzip) y en formato pbf. A diferencia de Spatialite, GeoJSON y Rasterlite, MBTiles no es un almacenamiento de datos sin formato. Es almacenamiento de datos en teselas.","title":"MBTiles"},{"location":"1_teoria/#tilejson","text":"TileJSON es un formato para describir un conjunto de teselas. Realiza un seguimiento de d\u00f3nde solicitar el conjunto de teselas, el nombre del conjunto de teselas y cualquier atribuci\u00f3n que sea necesaria al utilizar el conjunto de teselas. Esta especificaci\u00f3n intenta crear un est\u00e1ndar para representar metadatos sobre m\u00faltiples tipos de capas, para ayudar a los clientes en la configuraci\u00f3n y navegaci\u00f3n.","title":"tilejson"},{"location":"1_teoria/#overzoom","text":"Overzooming es una t\u00e9cnica espec\u00edfica de teselas vectorial que permite que una tesela se represente m\u00e1s all\u00e1 de su nivel de zoom previsto, por lo que contin\u00faa siendo visible en el mapa. Si un conjunto de teselas tiene un minzoom de 6 y un maxzoom de 12, esos son los rangos v\u00e1lidos calculados por el generador de teselas. Si ampliara el mapa m\u00e1s all\u00e1 del nivel de zoom 12, el renderizador del mapa puede seguir utilizando los datos del zoom 12 escalando los datos del vector hacia arriba. Esto, por supuesto, puede dar lugar a grandes simplificaciones de datos si las geometr\u00edas se representan demasiado por encima de su nivel real de detalle. Las teselas raster pierden claridad si ocurre overzoom. Por ejemplo, si est\u00e1 visualizando un conjunto de teselas raster con una extensi\u00f3n de zoom entre z0 y z6, si hace un zoom a un nivel de zoom m\u00e1s alto despu\u00e9s de z6, las im\u00e1genes se volver\u00e1n borrosas y dif\u00edciles de ver. Los efectos del overzoom no son tan notables con las teselas vector, ya que los datos vectoriales no se almacenan en un formato basado en p\u00edxeles, sino que se codifican y calculan a partir de una serie de puntos, l\u00edneas y pol\u00edgonos. Overzoom nivel zoom 16 vs nivel zoom 19.","title":"Overzoom"},{"location":"1_teoria/#presentacion-de-ejemplos-visuales-hechos-con-vt","text":"","title":"Presentaci\u00f3n de ejemplos visuales hechos con vt"},{"location":"1_teoria/#terreno","text":"https://openicgc.github.io/","title":"Terreno"},{"location":"1_teoria/#luces-la","text":"","title":"Luces LA"},{"location":"1_teoria/#edificios-con-musica","text":"https://codepen.io/jwhazel/pen/NYzpWG blog explicativo https://medium.com/@erdag/mappox-mapmadness18-round-4-1251a8c10421","title":"Edificios con m\u00fasica"},{"location":"1_teoria/#tematico-filtro","text":"","title":"Tem\u00e1tico filtro"},{"location":"1_teoria/#filtrado-al-vuelo","text":"","title":"Filtrado al vuelo"},{"location":"1_teoria/#mapa-de-calor","text":"","title":"Mapa de calor"},{"location":"1_teoria/#esquema-general-de-lo-que-se-va-a-hacer-en-el-taller","text":"Esquema taller","title":"Esquema general de lo que se va a hacer en el taller"},{"location":"2_visor_simple/","text":"C\u00f3mo visualizar teselas vectoriales Servidor web Para ver las aplicaciones que desarrollaremos durante el taller necesitamos publicarlas mediante un servidor web. En nuestro caso usaremos live-server , que permite servir los contenidos de un directorio y recargar la p\u00e1gina autom\u00e1ticamente cuando se modifica el contenido de alg\u00fan fichero. Para instalarlo, se usar\u00e1 el comando: 1 npm install -g live-server Para arrancarlo, basta con situarse en el directorio que queramos servir y ejecutar: 1 2 3 4 cd ~/Desktop/taller-vt mkdir visor cd visor live-server Se abrir\u00e1 el navegador por defecto con la direcci\u00f3n http://127.0.0.1:8080/ y se mostrar\u00e1 el contenido del directorio para poder navegar por \u00e9l. Deja la ventana del terminal abierta, y usa la combinaci\u00f3n de teclas Ctrl + C para parar el servidor. Hola Mundo Vamos a crear un fichero barcelona.html . Abre una nueva ventana de terminal (recuerda dejar el servidor activo) y ejecuta Visual Studio Code (o el editor que prefieras): 1 code ~/Desktop/taller-vt Crea un fichero en el directorio visor llamado barcelona.html : 1 2 3 4 5 6 7 8 9 10 11 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title / head body id = map Hola mundo / body / html Recargar la p\u00e1gina http://127.0.0.1:8080/ en el navegador. Se deber\u00eda ver un \"Hola mundo\". Hola Mapa En este primer ejemplo crearemos un visor de mapas utilizando la librer\u00eda de Mapbox GL JS. Tanto los datos procedente de teselas vectoriales \u00f3 vector tiles (VT) como el estilo para simbolizar los mismos se encuentran en la red. Modificar el archivo barcelona.html para que contenga el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : https://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); / script / body / html Resultado visor simple Inspector de datos El control mapbox-gl-inspect permite ver todos los elementos de un VT y tambi\u00e9n permite pasar el cursor sobre los elementos para ver sus propiedades. Agregar el c\u00f3digo de la librer\u00eda, e instanciar el control tras crear el mapa: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script link href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css rel = stylesheet / script src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : https://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script / body / html Se recargar\u00e1 la p\u00e1gina en el navegador con un nuevo bot\u00f3n que permite la \"visi\u00f3n de rayos X\" sobre los datos. Inspect Contenido de un fichero de estilo Como vemos, el visor es muy sencillo, y parece que toda la \"magia\" se esconde en el fichero de estilo tras la URL https://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json . Si lo abrimos, es un objeto JSON bastante complejo, pero si nos fijamos en las propiedades de primer nivel, son pocas. Las principales: 1 2 3 4 5 6 7 8 { version : 8 , name : OSM Bright , sprite : https://openmaptiles.github.io/osm-bright-gl-style/sprite , glyphs : https://free.tilehosting.com/fonts/{fontstack}/{range}.pbf?key=RiS4gsgZPZqeeMlIyxFo , sources : { ... }, layers : [ ... ] } version es obligatoria y siempre es 8. name es opcional pero conveniente, es una etiqueta para mostrar el nombre del estilo. sprite indica de d\u00f3nde obtener el conjunto de iconos necesarios para simbolizar. glyphs : indica de d\u00f3nde obtener el conjunto de tipograf\u00edas necesarios para simbolizar. sources : los or\u00edgenes de datos. layers : las reglas de simbolizaci\u00f3n. El orden es importante: Se van dibujando de la primera (que queda por debajo) a la \u00faltima (que queda por encima). As\u00ed, la primera regla suele ser el color de fondo del mapa, y las \u00faltimas suelen ser la toponimia o los PoIs. En los pr\u00f3ximos cap\u00edtulos veremos en detalle c\u00f3mo usar sources , layers , sprites y glyphs . Habitualmente tambi\u00e9n se usan otras propiedades para indicar la vista inicial del mapa. Por ejemplo: 1 2 3 4 5 6 7 { ... center : [ 2.15 , 41.39 ], zoom : 12 , bearing : -45 , pitch : 0 } center : Coordenadas iniciales donde centrar el mapa [lon, lat] zoom : Zoom inicial del mapa bearing : Rotaci\u00f3n inicial del mapa (en grados) pitch : Inclinaci\u00f3n inicial del mapa para verlo en perspectiva (de 0 a 60 grados) Tip La especificaci\u00f3n completa del fichero de estilo es parte de la documentaci\u00f3n on-line de Mapbox GL JS . Tip Si quisi\u00e9ramos editar el fichero de estilo, basta con guardarnos una copia local junto a barcelona.html y modificar la propiedad style para apuntar a una URL relativa. Lo veremos con m\u00e1s detalle en el punto 6.","title":"C\u00f3mo visualizar teselas vectoriales"},{"location":"2_visor_simple/#como-visualizar-teselas-vectoriales","text":"","title":"C\u00f3mo visualizar teselas vectoriales"},{"location":"2_visor_simple/#servidor-web","text":"Para ver las aplicaciones que desarrollaremos durante el taller necesitamos publicarlas mediante un servidor web. En nuestro caso usaremos live-server , que permite servir los contenidos de un directorio y recargar la p\u00e1gina autom\u00e1ticamente cuando se modifica el contenido de alg\u00fan fichero. Para instalarlo, se usar\u00e1 el comando: 1 npm install -g live-server Para arrancarlo, basta con situarse en el directorio que queramos servir y ejecutar: 1 2 3 4 cd ~/Desktop/taller-vt mkdir visor cd visor live-server Se abrir\u00e1 el navegador por defecto con la direcci\u00f3n http://127.0.0.1:8080/ y se mostrar\u00e1 el contenido del directorio para poder navegar por \u00e9l. Deja la ventana del terminal abierta, y usa la combinaci\u00f3n de teclas Ctrl + C para parar el servidor.","title":"Servidor web"},{"location":"2_visor_simple/#hola-mundo","text":"Vamos a crear un fichero barcelona.html . Abre una nueva ventana de terminal (recuerda dejar el servidor activo) y ejecuta Visual Studio Code (o el editor que prefieras): 1 code ~/Desktop/taller-vt Crea un fichero en el directorio visor llamado barcelona.html : 1 2 3 4 5 6 7 8 9 10 11 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title / head body id = map Hola mundo / body / html Recargar la p\u00e1gina http://127.0.0.1:8080/ en el navegador. Se deber\u00eda ver un \"Hola mundo\".","title":"Hola Mundo"},{"location":"2_visor_simple/#hola-mapa","text":"En este primer ejemplo crearemos un visor de mapas utilizando la librer\u00eda de Mapbox GL JS. Tanto los datos procedente de teselas vectoriales \u00f3 vector tiles (VT) como el estilo para simbolizar los mismos se encuentran en la red. Modificar el archivo barcelona.html para que contenga el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : https://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); / script / body / html Resultado visor simple","title":"Hola Mapa"},{"location":"2_visor_simple/#inspector-de-datos","text":"El control mapbox-gl-inspect permite ver todos los elementos de un VT y tambi\u00e9n permite pasar el cursor sobre los elementos para ver sus propiedades. Agregar el c\u00f3digo de la librer\u00eda, e instanciar el control tras crear el mapa: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script link href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css rel = stylesheet / script src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : https://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script / body / html Se recargar\u00e1 la p\u00e1gina en el navegador con un nuevo bot\u00f3n que permite la \"visi\u00f3n de rayos X\" sobre los datos. Inspect","title":"Inspector de datos"},{"location":"2_visor_simple/#contenido-de-un-fichero-de-estilo","text":"Como vemos, el visor es muy sencillo, y parece que toda la \"magia\" se esconde en el fichero de estilo tras la URL https://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json . Si lo abrimos, es un objeto JSON bastante complejo, pero si nos fijamos en las propiedades de primer nivel, son pocas. Las principales: 1 2 3 4 5 6 7 8 { version : 8 , name : OSM Bright , sprite : https://openmaptiles.github.io/osm-bright-gl-style/sprite , glyphs : https://free.tilehosting.com/fonts/{fontstack}/{range}.pbf?key=RiS4gsgZPZqeeMlIyxFo , sources : { ... }, layers : [ ... ] } version es obligatoria y siempre es 8. name es opcional pero conveniente, es una etiqueta para mostrar el nombre del estilo. sprite indica de d\u00f3nde obtener el conjunto de iconos necesarios para simbolizar. glyphs : indica de d\u00f3nde obtener el conjunto de tipograf\u00edas necesarios para simbolizar. sources : los or\u00edgenes de datos. layers : las reglas de simbolizaci\u00f3n. El orden es importante: Se van dibujando de la primera (que queda por debajo) a la \u00faltima (que queda por encima). As\u00ed, la primera regla suele ser el color de fondo del mapa, y las \u00faltimas suelen ser la toponimia o los PoIs. En los pr\u00f3ximos cap\u00edtulos veremos en detalle c\u00f3mo usar sources , layers , sprites y glyphs . Habitualmente tambi\u00e9n se usan otras propiedades para indicar la vista inicial del mapa. Por ejemplo: 1 2 3 4 5 6 7 { ... center : [ 2.15 , 41.39 ], zoom : 12 , bearing : -45 , pitch : 0 } center : Coordenadas iniciales donde centrar el mapa [lon, lat] zoom : Zoom inicial del mapa bearing : Rotaci\u00f3n inicial del mapa (en grados) pitch : Inclinaci\u00f3n inicial del mapa para verlo en perspectiva (de 0 a 60 grados) Tip La especificaci\u00f3n completa del fichero de estilo es parte de la documentaci\u00f3n on-line de Mapbox GL JS . Tip Si quisi\u00e9ramos editar el fichero de estilo, basta con guardarnos una copia local junto a barcelona.html y modificar la propiedad style para apuntar a una URL relativa. Lo veremos con m\u00e1s detalle en el punto 6.","title":"Contenido de un fichero de estilo"},{"location":"3_tileserver_gl/","text":"C\u00f3mo servir teselas vectoriales Instalaci\u00f3n de TileServer GL TileServer GL es un servidor de mapas de c\u00f3digo abierto creado para teselas vectoriales, y capaz de renderizar en teselas raster con MapBox GL Native engine en el lado del servidor. Proporciona mapas para aplicaciones web y m\u00f3viles. Es compatibles con Mapbox GL JS, Android SDK, iOS SDK, Leaflet, OpenLayers, HighDPI/Retina, SIG a trav\u00e9s de WMTS, etc. Si se quiere servir teselas raster lo mejor es utilizar la versi\u00f3n de Docker ya que son necesarias algunas librer\u00edas nativas que pueden variar dependiendo de la plataforma, estas librer\u00edas sirven para renderizar las teselas vectoriales en teselas raster. Si \u00fanicamente se quiere servir teselas vectoriales se puede utilizar el TileServer GL Light, que no tiene ninguna dependencia nativa ya que est\u00e1 desarrollado en javascript. Para este taller utilizaremos la versi\u00f3n Light ya que serviremos s\u00f3lo teselas vectoriales. Es necesario tener instalado Node.js versi\u00f3n 6. Warning tileserver-gl-light NO se instalar\u00e1 correctamente si estamos usando una versi\u00f3n de Node.js superior a la 6. Debemos activar esta versi\u00f3n de node con el comando: 1 2 nvm use 6 node -v # Deber\u00eda devolver: 6.x.x Una vez comprobada la versi\u00f3n de node: 1 2 npm install -g tileserver-gl-light@2.3.1 tileserver-gl-light -v # Deberia devolver: v2.3.1 Arranque con la configuraci\u00f3n por defecto Obtener datos de Barcelona Crear una carpeta llamada tileserver/data y copiar en ella el fichero `datos/barcelona.mbtiles: 1 2 3 cd ~/Desktop/taller-vt mkdir -p tileserver/data cp datos/barcelona.mbtiles tileserver/data Tip En la web de OpenMapTiles se pueden descargar datos de muchas otras ciudades, pa\u00edses, e incluso el planeta entero. Es gratu\u00edto, aunque hay que registrarse y los datos no est\u00e1n del todo actualizados. Ahora arrancaremos el servidor en el puerto 8081 (par\u00e1metro -p ): 1 2 cd tileserver tileserver-gl-light data/barcelona.mbtiles -p 8081 Abrir el navegador y escribir http://localhost:8081 . Aparecer\u00e1 la p\u00e1gina del TileServer. Dejar el terminal abierto con el servidor arrancado. TileServer GL Light Modificar el visor de mapas Modificaremos nuestro archivo barcelona.html para que el visor de mapas consuma las teselas vectoriales servidas por nuestro TileServer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script link href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css rel = stylesheet / script src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/osm-bright/style.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script / body / html Configuraci\u00f3n completa Vamos a extraer un primer fichero de configuraci\u00f3n. Para ello, debemos parar el servidor tileserver-gl-light y vamos a arrancarlo de nuevo, pero esta vez con la opci\u00f3n -V (verbose): 1 tileserver-gl-light data/barcelona.mbtiles -p 8081 -V Observaremos que nos responde \"Automatically creating config file for barcelona.mbtiles\", y a continuaci\u00f3n nos muestra el fichero de configuraci\u00f3n que ha autogenerado, y que aproximadamente tendr\u00e1 este aspecto: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { options : { paths : { root : /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles , fonts : fonts , styles : styles , mbtiles : /home/user/Desktop/taller-vt/tileserver/data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ -180 , -85.0511 , 180 , 85.0511 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ -180 , -85.0511 , 180 , 85.0511 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles } } } La configuraci\u00f3n se divide en estos tres elementos: options.paths : Rutas de donde obtener los diferentes recursos: mbtiles (datos), fonts (tambi\u00e9n llamados glyphs ), y styles . styles : Ficheros de estilos y alguna informaci\u00f3n adicional para generar el fichero auxiliar TileJSON. data : Origenes de datos. Apunta a los diferentes ficheros .mbtiles que queramos servir. Copiemos la configuraci\u00f3n que nos ha devuelto tileserver-gl-light -V en un nuevo fichero llamado tileserver/config.json . Warning Atenci\u00f3n a la ruta de options.paths , que puede variar ligeramente entre estos apuntes y la ruta en vuestra m\u00e1quina, dependiendo de la versi\u00f3n exacta de node que teng\u00e1is instalada. Tened en cuenta esta discrepancia en la ruta para las pr\u00f3ximas instrucciones. El resto de la configuraci\u00f3n deber\u00eda ser la misma. Por defecto Tileserver GL viene con dos estilos incorporados ( klokantech-basic y osm-bright ) y cuatro tipograf\u00edas ( Open Sans en sus varintes Regular , Italic , Bold y Semibold ), que se esconden en la ruta profunda indicada en options.paths.root . Vamos a copiar estos recursos en nuestro directorio de trabajo: 1 2 3 cd ~/Desktop/taller-vt/tileserver cp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/styles . cp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/fonts . Comprobemos que en ~/Desktop/taller-vt/tileserver tenemos tres directorios data , fonts y styles , y el fichero config.json . Modifiquemos ahora el fichero config.json para apuntar a nuestros recursos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles } } } De paso hemos modificado el BBOX de los datos de Barcelona, que no estaba bien ajustado. Ahora paramos y arrancamos tileserver de nuevo, sin m\u00e1s par\u00e1metros que el puerto, y leer\u00e1 autom\u00e1ticamente la configuraci\u00f3n del nuevo fichero config.json : 1 tileserver-gl-light -p 8081 Tileserver deber\u00e1 decir \"Using specified config file from config.json\". Si vamos a http://localhost:8081 deber\u00edamos ver lo mismo que antes, pero ahora podremos ir a\u00f1adiendo y modificando los recursos (datos, estilos, tipograf\u00edas e iconos) que servimos. A\u00f1adiendo datos de edificios Vamos a copiar un nuevo .mbtiles con informaci\u00f3n de edificios: 1 cp ../datos/buildings.mbtiles data/ Y lo vamos a a\u00f1adir al fichero config.json : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles }, buildings : { mbtiles : buildings.mbtiles } } } Paramos el servidor y arrancamos de nuevo. Recargando la p\u00e1gina http://localhost:8081 veremos el nuevo dataset: Haciendo click en \"Preview\": Efectivamente, se trata de una capa con m\u00e1s de 500.000 construcciones de catastro, con la referencia de la parcela catastral a la que pertenece cada construcci\u00f3n, y el n\u00famero de plantas para cada construcci\u00f3n. Question \u00bfPara qu\u00e9 sirve el \"TileJSON\" de un dataset? En \u00faltima instancia, las teselas vectoriales se sirven en un servicio HTTP con una URL que acaba en /{z}/{x}/{y}.pbf . De hecho, en el estilo de mapbox podemos indicar esta url directamente, as\u00ed: 1 2 3 4 5 6 7 sources : { ... buildings , { type : vector , tiles : [ http://localhost:8081/data/buildings/{z}/{x}/{y}.pbf ] } } Aunque el m\u00e9todo preferido es apuntar a un TileJSON. Esta configuraci\u00f3n ser\u00eda equivalente a la anterior, pero m\u00e1s correcta: 1 2 3 4 5 6 7 sources : { ... buildings , { type : vector , url : http://localhost:8081/data/buildings.json } } El fichero TileJSON acaba teniendo una propiedad \"tiles\" que apunta al servicio XYZ, pero adem\u00e1s contiene otros metadatos \u00fatiles para quien consume el dataset. Por ejemplo, el rango de niveles de zoom v\u00e1lidos para el dataset ( minzoom , maxzoom ) y el bbox v\u00e1lido ( bounds ), lo que evita hacer peticiones fuera de rango al servidor, y otros metadatos como las \"capas\" contenidas en cada Vector Tile, y los atributos de cada capa. Esto ayuda a funcionar al InspectorPlugin , y tambi\u00e9n nos da informaci\u00f3n a la hora de simbolizar la capa, ya que nos describe el esquema de los datos. A\u00f1adiendo los nuevos datos al visor Para visualizar los datos de edificios en barcelona.html , usar el siguiente c\u00f3digo javascript: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/klokantech-basic/style.json , center : [ 2.19224 , 41.38585 ], zoom : 15 , bearing : - 45 , pitch : 60 , hash : true }); map . on ( load , function () { map . addSource ( buildings , { type : vector , url : http://localhost:8081/data/buildings.json }); map . addLayer ({ id : buildings , source : buildings , source-layer : buildingpart , type : fill , paint : { fill-opacity : 0.75 , fill-color : #E9DFCD , fill-outline-color : #000 } }); }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script Incluso podemos usar una regla de simbolizaci\u00f3n de extrusi\u00f3n para verlos en 3D: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/klokantech-basic/style.json , center : [ 2.19224 , 41.38585 ], zoom : 15 , bearing : - 45 , pitch : 60 , hash : true }); map . on ( load , function () { map . addSource ( buildings , { type : vector , url : http://localhost:8081/data/buildings.json }); map . addLayer ({ id : buildings , source : buildings , source-layer : buildingpart , type : fill-extrusion , paint : { fill-extrusion-opacity : 0.75 , fill-extrusion-color : #E9DFCD , fill-extrusion-height : [ * , 3 , [ get , floors ]] } }); }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script En la regla de simbolizaci\u00f3n hemos utilizado como altura de la extrusi\u00f3n el n\u00famero de plantas multiplicado por 3.","title":"C\u00f3mo servir teselas vectoriales"},{"location":"3_tileserver_gl/#como-servir-teselas-vectoriales","text":"","title":"C\u00f3mo servir teselas vectoriales"},{"location":"3_tileserver_gl/#instalacion-de-tileserver-gl","text":"TileServer GL es un servidor de mapas de c\u00f3digo abierto creado para teselas vectoriales, y capaz de renderizar en teselas raster con MapBox GL Native engine en el lado del servidor. Proporciona mapas para aplicaciones web y m\u00f3viles. Es compatibles con Mapbox GL JS, Android SDK, iOS SDK, Leaflet, OpenLayers, HighDPI/Retina, SIG a trav\u00e9s de WMTS, etc. Si se quiere servir teselas raster lo mejor es utilizar la versi\u00f3n de Docker ya que son necesarias algunas librer\u00edas nativas que pueden variar dependiendo de la plataforma, estas librer\u00edas sirven para renderizar las teselas vectoriales en teselas raster. Si \u00fanicamente se quiere servir teselas vectoriales se puede utilizar el TileServer GL Light, que no tiene ninguna dependencia nativa ya que est\u00e1 desarrollado en javascript. Para este taller utilizaremos la versi\u00f3n Light ya que serviremos s\u00f3lo teselas vectoriales. Es necesario tener instalado Node.js versi\u00f3n 6. Warning tileserver-gl-light NO se instalar\u00e1 correctamente si estamos usando una versi\u00f3n de Node.js superior a la 6. Debemos activar esta versi\u00f3n de node con el comando: 1 2 nvm use 6 node -v # Deber\u00eda devolver: 6.x.x Una vez comprobada la versi\u00f3n de node: 1 2 npm install -g tileserver-gl-light@2.3.1 tileserver-gl-light -v # Deberia devolver: v2.3.1","title":"Instalaci\u00f3n de TileServer GL"},{"location":"3_tileserver_gl/#arranque-con-la-configuracion-por-defecto","text":"","title":"Arranque con la configuraci\u00f3n por defecto"},{"location":"3_tileserver_gl/#obtener-datos-de-barcelona","text":"Crear una carpeta llamada tileserver/data y copiar en ella el fichero `datos/barcelona.mbtiles: 1 2 3 cd ~/Desktop/taller-vt mkdir -p tileserver/data cp datos/barcelona.mbtiles tileserver/data Tip En la web de OpenMapTiles se pueden descargar datos de muchas otras ciudades, pa\u00edses, e incluso el planeta entero. Es gratu\u00edto, aunque hay que registrarse y los datos no est\u00e1n del todo actualizados. Ahora arrancaremos el servidor en el puerto 8081 (par\u00e1metro -p ): 1 2 cd tileserver tileserver-gl-light data/barcelona.mbtiles -p 8081 Abrir el navegador y escribir http://localhost:8081 . Aparecer\u00e1 la p\u00e1gina del TileServer. Dejar el terminal abierto con el servidor arrancado. TileServer GL Light","title":"Obtener datos de Barcelona"},{"location":"3_tileserver_gl/#modificar-el-visor-de-mapas","text":"Modificaremos nuestro archivo barcelona.html para que el visor de mapas consuma las teselas vectoriales servidas por nuestro TileServer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script link href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css rel = stylesheet / script src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/osm-bright/style.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script / body / html","title":"Modificar el visor de mapas"},{"location":"3_tileserver_gl/#configuracion-completa","text":"Vamos a extraer un primer fichero de configuraci\u00f3n. Para ello, debemos parar el servidor tileserver-gl-light y vamos a arrancarlo de nuevo, pero esta vez con la opci\u00f3n -V (verbose): 1 tileserver-gl-light data/barcelona.mbtiles -p 8081 -V Observaremos que nos responde \"Automatically creating config file for barcelona.mbtiles\", y a continuaci\u00f3n nos muestra el fichero de configuraci\u00f3n que ha autogenerado, y que aproximadamente tendr\u00e1 este aspecto: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { options : { paths : { root : /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles , fonts : fonts , styles : styles , mbtiles : /home/user/Desktop/taller-vt/tileserver/data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ -180 , -85.0511 , 180 , 85.0511 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ -180 , -85.0511 , 180 , 85.0511 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles } } } La configuraci\u00f3n se divide en estos tres elementos: options.paths : Rutas de donde obtener los diferentes recursos: mbtiles (datos), fonts (tambi\u00e9n llamados glyphs ), y styles . styles : Ficheros de estilos y alguna informaci\u00f3n adicional para generar el fichero auxiliar TileJSON. data : Origenes de datos. Apunta a los diferentes ficheros .mbtiles que queramos servir. Copiemos la configuraci\u00f3n que nos ha devuelto tileserver-gl-light -V en un nuevo fichero llamado tileserver/config.json . Warning Atenci\u00f3n a la ruta de options.paths , que puede variar ligeramente entre estos apuntes y la ruta en vuestra m\u00e1quina, dependiendo de la versi\u00f3n exacta de node que teng\u00e1is instalada. Tened en cuenta esta discrepancia en la ruta para las pr\u00f3ximas instrucciones. El resto de la configuraci\u00f3n deber\u00eda ser la misma. Por defecto Tileserver GL viene con dos estilos incorporados ( klokantech-basic y osm-bright ) y cuatro tipograf\u00edas ( Open Sans en sus varintes Regular , Italic , Bold y Semibold ), que se esconden en la ruta profunda indicada en options.paths.root . Vamos a copiar estos recursos en nuestro directorio de trabajo: 1 2 3 cd ~/Desktop/taller-vt/tileserver cp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/styles . cp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/fonts . Comprobemos que en ~/Desktop/taller-vt/tileserver tenemos tres directorios data , fonts y styles , y el fichero config.json . Modifiquemos ahora el fichero config.json para apuntar a nuestros recursos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles } } } De paso hemos modificado el BBOX de los datos de Barcelona, que no estaba bien ajustado. Ahora paramos y arrancamos tileserver de nuevo, sin m\u00e1s par\u00e1metros que el puerto, y leer\u00e1 autom\u00e1ticamente la configuraci\u00f3n del nuevo fichero config.json : 1 tileserver-gl-light -p 8081 Tileserver deber\u00e1 decir \"Using specified config file from config.json\". Si vamos a http://localhost:8081 deber\u00edamos ver lo mismo que antes, pero ahora podremos ir a\u00f1adiendo y modificando los recursos (datos, estilos, tipograf\u00edas e iconos) que servimos.","title":"Configuraci\u00f3n completa"},{"location":"3_tileserver_gl/#anadiendo-datos-de-edificios","text":"Vamos a copiar un nuevo .mbtiles con informaci\u00f3n de edificios: 1 cp ../datos/buildings.mbtiles data/ Y lo vamos a a\u00f1adir al fichero config.json : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles }, buildings : { mbtiles : buildings.mbtiles } } } Paramos el servidor y arrancamos de nuevo. Recargando la p\u00e1gina http://localhost:8081 veremos el nuevo dataset: Haciendo click en \"Preview\": Efectivamente, se trata de una capa con m\u00e1s de 500.000 construcciones de catastro, con la referencia de la parcela catastral a la que pertenece cada construcci\u00f3n, y el n\u00famero de plantas para cada construcci\u00f3n. Question \u00bfPara qu\u00e9 sirve el \"TileJSON\" de un dataset? En \u00faltima instancia, las teselas vectoriales se sirven en un servicio HTTP con una URL que acaba en /{z}/{x}/{y}.pbf . De hecho, en el estilo de mapbox podemos indicar esta url directamente, as\u00ed: 1 2 3 4 5 6 7 sources : { ... buildings , { type : vector , tiles : [ http://localhost:8081/data/buildings/{z}/{x}/{y}.pbf ] } } Aunque el m\u00e9todo preferido es apuntar a un TileJSON. Esta configuraci\u00f3n ser\u00eda equivalente a la anterior, pero m\u00e1s correcta: 1 2 3 4 5 6 7 sources : { ... buildings , { type : vector , url : http://localhost:8081/data/buildings.json } } El fichero TileJSON acaba teniendo una propiedad \"tiles\" que apunta al servicio XYZ, pero adem\u00e1s contiene otros metadatos \u00fatiles para quien consume el dataset. Por ejemplo, el rango de niveles de zoom v\u00e1lidos para el dataset ( minzoom , maxzoom ) y el bbox v\u00e1lido ( bounds ), lo que evita hacer peticiones fuera de rango al servidor, y otros metadatos como las \"capas\" contenidas en cada Vector Tile, y los atributos de cada capa. Esto ayuda a funcionar al InspectorPlugin , y tambi\u00e9n nos da informaci\u00f3n a la hora de simbolizar la capa, ya que nos describe el esquema de los datos.","title":"A\u00f1adiendo datos de edificios"},{"location":"3_tileserver_gl/#anadiendo-los-nuevos-datos-al-visor","text":"Para visualizar los datos de edificios en barcelona.html , usar el siguiente c\u00f3digo javascript: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/klokantech-basic/style.json , center : [ 2.19224 , 41.38585 ], zoom : 15 , bearing : - 45 , pitch : 60 , hash : true }); map . on ( load , function () { map . addSource ( buildings , { type : vector , url : http://localhost:8081/data/buildings.json }); map . addLayer ({ id : buildings , source : buildings , source-layer : buildingpart , type : fill , paint : { fill-opacity : 0.75 , fill-color : #E9DFCD , fill-outline-color : #000 } }); }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script Incluso podemos usar una regla de simbolizaci\u00f3n de extrusi\u00f3n para verlos en 3D: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/klokantech-basic/style.json , center : [ 2.19224 , 41.38585 ], zoom : 15 , bearing : - 45 , pitch : 60 , hash : true }); map . on ( load , function () { map . addSource ( buildings , { type : vector , url : http://localhost:8081/data/buildings.json }); map . addLayer ({ id : buildings , source : buildings , source-layer : buildingpart , type : fill-extrusion , paint : { fill-extrusion-opacity : 0.75 , fill-extrusion-color : #E9DFCD , fill-extrusion-height : [ * , 3 , [ get , floors ]] } }); }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script En la regla de simbolizaci\u00f3n hemos utilizado como altura de la extrusi\u00f3n el n\u00famero de plantas multiplicado por 3.","title":"A\u00f1adiendo los nuevos datos al visor"},{"location":"4_tippecanoe/","text":"C\u00f3mo crear teselas vectoriales Los datos de Natural Earth En el apartado de descargas de Natural Earth hay varios conjuntos de datos en formato Shapefile, seg\u00fan la escala. En el taller trabajaremos con un subconjunto de los datos de la escala 1:10M (1:10.000.000). Para ahorrarnos la transformaci\u00f3n de Shapefile a GeoJSON, utilizaremos los datos procedentes de https://github.com/nvkelso/natural-earth-vector/ . En concreto usaremos las siguientes capas: Cultural Admin 0 \u2013 Countries (247 pa\u00edses en el mundo. Groenlandia separada de Dinamarca) Populated Places (Puntos de ciudades y pueblos) Roads (Carreteras principales) Railroads (V\u00edas de Trenes) Airports (Aeropuertos) Physical Coastline (L\u00ednea de costa que incluyen islas principales) Land (Pol\u00edgonos terrestres que incluyen islas principales) Ocean (Oceano) Rivers + lake centerlines (Rios en \u00fanica l\u00ednea que incluyen l\u00edneas centrales de lagos) Lakes + Reservoirs (Lagos naturales y artificiales) Nosotros descargaremos las 10 capas de un zip y las descomprimiremos en taller-vt/datos/naturalearth : 1 2 3 cd ~/Desktop/taller-vt/datos wget https://geoinquiets.github.io/taller-vt/downloads/naturalearth.zip unzip naturalearth.zip Tippecanoe Tippecanoe es la herramienta que permite crear teselas vectoriales de grandes colecciones de elementos en formato GeoJSON. El objetivo de Tippecanoe es permitir una visi\u00f3n de sus datos independiente de la escala, de modo que en cualquier nivel, desde el mundo entero hasta un solo edificio, se pueda apreciar la densidad y la textura de los datos, en lugar de una simplificaci\u00f3n geom\u00e9trica, que puede eliminar v\u00e9rtices importantes que cambien la apariencia de los datos en su versi\u00f3n simplificada. Algunos ejemplos: Teniendo todo el callejero de OpenStreetMap, la vista general devolver\u00e1 algo que se parece a \"Todas las calles\" en lugar de algo que parece un atlas de carreteras interestatal. Teniendo todas las plantas de edificios de una ciudad, en la vista general donde los edificios individuales ya no sean perceptibles, a\u00fan deber\u00edas poder ver la extensi\u00f3n y variedad del desarrollo en cada vecindario, no solo para los edificios m\u00e1s voluminosos. Esto hace que la calidad de los resultados de Tippecanoe sea muy superior a otras alternativas, que utilizan algoritmos de simplificaci\u00f3n m\u00e1s convencionales, motivo por el cual lo recomendamos en este taller. Adem\u00e1s, es sorprendentemente r\u00e1pido procesando los datos. Creando el fichero mbtiles Vamos a crear un fichero mbtiles llamado natural_earth.mbtiles que contendr\u00e1 nuestras 10 capas. Para crear el mbtiles utilizaremos las siguientes opciones del Tippecanoe : -o nombre.mbtiles : nombre del archivo de salida. -zg : Estima un maxzoom razonable basado en la resoluci\u00f3n de los datos. --drop-densest-as-needed : Si una tesela es demasiado pesada, intenta reducirla a menos de 500 KB reduciendo su detalle. -L nombre:archivo.json : permite definir nombres de capa para cada archivo individual. Para generar el archivo mbtiles escribiremos lo siguiente en el terminal: 1 2 3 4 5 6 7 8 9 10 11 12 cd naturalearth tippecanoe -o natural_earth.mbtiles -zg --drop-densest-as-needed \\ -L ocean:ne_10m_ocean.geojson \\ -L land:ne_10m_land.geojson \\ -L admin:ne_10m_admin_0_countries.geojson \\ -L coastline:ne_10m_coastline.geojson \\ -L lakes:ne_10m_lakes.geojson \\ -L rivers:ne_10m_rivers_lake_centerlines.geojson \\ -L rail:ne_10m_railroads.geojson \\ -L roads:ne_10m_roads.geojson \\ -L cities:ne_10m_populated_places.geojson \\ -L airports:ne_10m_airports.geojson Publicando el mbtiles A\u00f1adiremos el mbtiles a Tileserver GL igual que hicimos con los edificios de Barcelona: 1 2 mv natural_earth.mbtiles ../../tileserver/data cd ../../tileserver Editamos config.json y a\u00f1adimos la nueva capa: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { ... data : { v3 : { mbtiles : barcelona.mbtiles }, buildings : { mbtiles : buildings.mbtiles }, natural_earth : { mbtiles : natural_earth.mbtiles } } } Tras parar y arrancar el tileserver de nuevo, abrir el navegador y escribir http://localhost:8081 y comprobar que aparece la p\u00e1gina del TileServer con nuestro mbtiles: Hacer click en el bot\u00f3n de Inspect y comprobar que en el mapa aparecen todas las capas agregadas al mbtiles: As\u00ed pues, una tesela vectorial contiene varias \"capas\" internamente. En una regla de simbolizaci\u00f3n, deber\u00e1 indicarse tanto origen de datos ( \"source\": \"natural_earth\" ), como la capa dentro de la tesela ( \"source_layer\": \"roads\" ).","title":"C\u00f3mo crear teselas vectoriales"},{"location":"4_tippecanoe/#como-crear-teselas-vectoriales","text":"","title":"C\u00f3mo crear teselas vectoriales"},{"location":"4_tippecanoe/#los-datos-de-natural-earth","text":"En el apartado de descargas de Natural Earth hay varios conjuntos de datos en formato Shapefile, seg\u00fan la escala. En el taller trabajaremos con un subconjunto de los datos de la escala 1:10M (1:10.000.000). Para ahorrarnos la transformaci\u00f3n de Shapefile a GeoJSON, utilizaremos los datos procedentes de https://github.com/nvkelso/natural-earth-vector/ . En concreto usaremos las siguientes capas: Cultural Admin 0 \u2013 Countries (247 pa\u00edses en el mundo. Groenlandia separada de Dinamarca) Populated Places (Puntos de ciudades y pueblos) Roads (Carreteras principales) Railroads (V\u00edas de Trenes) Airports (Aeropuertos) Physical Coastline (L\u00ednea de costa que incluyen islas principales) Land (Pol\u00edgonos terrestres que incluyen islas principales) Ocean (Oceano) Rivers + lake centerlines (Rios en \u00fanica l\u00ednea que incluyen l\u00edneas centrales de lagos) Lakes + Reservoirs (Lagos naturales y artificiales) Nosotros descargaremos las 10 capas de un zip y las descomprimiremos en taller-vt/datos/naturalearth : 1 2 3 cd ~/Desktop/taller-vt/datos wget https://geoinquiets.github.io/taller-vt/downloads/naturalearth.zip unzip naturalearth.zip","title":"Los datos de Natural Earth"},{"location":"4_tippecanoe/#tippecanoe","text":"Tippecanoe es la herramienta que permite crear teselas vectoriales de grandes colecciones de elementos en formato GeoJSON. El objetivo de Tippecanoe es permitir una visi\u00f3n de sus datos independiente de la escala, de modo que en cualquier nivel, desde el mundo entero hasta un solo edificio, se pueda apreciar la densidad y la textura de los datos, en lugar de una simplificaci\u00f3n geom\u00e9trica, que puede eliminar v\u00e9rtices importantes que cambien la apariencia de los datos en su versi\u00f3n simplificada. Algunos ejemplos: Teniendo todo el callejero de OpenStreetMap, la vista general devolver\u00e1 algo que se parece a \"Todas las calles\" en lugar de algo que parece un atlas de carreteras interestatal. Teniendo todas las plantas de edificios de una ciudad, en la vista general donde los edificios individuales ya no sean perceptibles, a\u00fan deber\u00edas poder ver la extensi\u00f3n y variedad del desarrollo en cada vecindario, no solo para los edificios m\u00e1s voluminosos. Esto hace que la calidad de los resultados de Tippecanoe sea muy superior a otras alternativas, que utilizan algoritmos de simplificaci\u00f3n m\u00e1s convencionales, motivo por el cual lo recomendamos en este taller. Adem\u00e1s, es sorprendentemente r\u00e1pido procesando los datos.","title":"Tippecanoe"},{"location":"4_tippecanoe/#creando-el-fichero-mbtiles","text":"Vamos a crear un fichero mbtiles llamado natural_earth.mbtiles que contendr\u00e1 nuestras 10 capas. Para crear el mbtiles utilizaremos las siguientes opciones del Tippecanoe : -o nombre.mbtiles : nombre del archivo de salida. -zg : Estima un maxzoom razonable basado en la resoluci\u00f3n de los datos. --drop-densest-as-needed : Si una tesela es demasiado pesada, intenta reducirla a menos de 500 KB reduciendo su detalle. -L nombre:archivo.json : permite definir nombres de capa para cada archivo individual. Para generar el archivo mbtiles escribiremos lo siguiente en el terminal: 1 2 3 4 5 6 7 8 9 10 11 12 cd naturalearth tippecanoe -o natural_earth.mbtiles -zg --drop-densest-as-needed \\ -L ocean:ne_10m_ocean.geojson \\ -L land:ne_10m_land.geojson \\ -L admin:ne_10m_admin_0_countries.geojson \\ -L coastline:ne_10m_coastline.geojson \\ -L lakes:ne_10m_lakes.geojson \\ -L rivers:ne_10m_rivers_lake_centerlines.geojson \\ -L rail:ne_10m_railroads.geojson \\ -L roads:ne_10m_roads.geojson \\ -L cities:ne_10m_populated_places.geojson \\ -L airports:ne_10m_airports.geojson","title":"Creando el fichero mbtiles"},{"location":"4_tippecanoe/#publicando-el-mbtiles","text":"A\u00f1adiremos el mbtiles a Tileserver GL igual que hicimos con los edificios de Barcelona: 1 2 mv natural_earth.mbtiles ../../tileserver/data cd ../../tileserver Editamos config.json y a\u00f1adimos la nueva capa: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { ... data : { v3 : { mbtiles : barcelona.mbtiles }, buildings : { mbtiles : buildings.mbtiles }, natural_earth : { mbtiles : natural_earth.mbtiles } } } Tras parar y arrancar el tileserver de nuevo, abrir el navegador y escribir http://localhost:8081 y comprobar que aparece la p\u00e1gina del TileServer con nuestro mbtiles: Hacer click en el bot\u00f3n de Inspect y comprobar que en el mapa aparecen todas las capas agregadas al mbtiles: As\u00ed pues, una tesela vectorial contiene varias \"capas\" internamente. En una regla de simbolizaci\u00f3n, deber\u00e1 indicarse tanto origen de datos ( \"source\": \"natural_earth\" ), como la capa dentro de la tesela ( \"source_layer\": \"roads\" ).","title":"Publicando el mbtiles"},{"location":"5_sprites_glyphs/","text":"Sprites y Glyphs Sprites Definici\u00f3n Un sprite es una imagen individual que contiene todos los iconos incluidos en un estilo. Al combinar muchas im\u00e1genes peque\u00f1as en una sola imagen (sprite), se puede reducir el n\u00famero de solicitudes necesarias para recuperar todas las im\u00e1genes, mejorar el rendimiento y hacer que el mapa sea m\u00e1s r\u00e1pido. Los Sprites pueden tener un tama\u00f1o m\u00e1ximo de 1024x1024 p\u00edxeles (o 2048x2048 para pantallas con alta DPI). Cada sprite viene acompa\u00f1ado de un archivo JSON donde se define el nombre de cada icono, y su posici\u00f3n y tama\u00f1o para saber c\u00f3mo \"recortarlo\" de la imagen com\u00fan. M\u00e1s informaci\u00f3n en sobre sprites https://www.mapbox.com/help/define-sprite/ Cada uno de los iconos contenidos en un sprite se puede usar como textura para el fondo del mapa, patr\u00f3n de relleno para un pol\u00edgono, patr\u00f3n de dibujo para una l\u00ednea, o una imagen de icono (s\u00edmbolo puntual). La propiedad sprite de un estilo apunta a una URL incompleta , a partir de la cual se pueden encontrar los diferentes ficheros (sprites y json complementario). Por ejemplo, si en el style.json se indica: 1 2 3 4 { ... sprite : http://localhost:8081/styles/osm-bright/sprite } En realidad dicha URL no existe. Pero s\u00ed existen los siguientes recursos (a\u00f1adiendo .png , .json , @2x.png y @2x.json respectivamente): http://localhost:8081/styles/osm-bright/sprite.png Sprite a resoluci\u00f3n convencional http://localhost:8081/styles/osm-bright/sprite.json JSON que define cada icono dentro del sprite http://localhost:8081/styles/osm-bright/sprite@2x.png Sprite a resoluci\u00f3n doble (para pantallas Retina) http://localhost:8081/styles/osm-bright/sprite@2x.json JSON que define cada icono dentro del sprite de resoluci\u00f3n doble Ejemplo de sprite: Uno de los elementos definidos en el JSON: 1 2 3 4 5 6 7 8 9 10 11 { ... airport_11 : { height : 17 , width : 17 , x : 17 , y : 0 , pixelRatio : 1 }, .... } C\u00f3mo crear tus propios sprites Para generar los sprites a partir de im\u00e1genes individuales hay que crear los cuatro archivos. Esto se podr\u00eda hacer manualmente con un editor de texto, un editor de im\u00e1genes y mucha paciencia, pero afortunadamente existen herramientas que lo automatizan. Los sprites convencionales para la web difieren de los de Mapbox, ya que utilizan una imagen compuesta png y un archivo css con las reglas de simbolizaci\u00f3n para su aprovechamiento en p\u00e1ginas web. Mapbox GL, en cambio, necesita el fichero json , no un CSS. Para generar los sprites y sus json a partir de una colecci\u00f3n de im\u00e1genes en formato SVG, se recomienda el uso de la librer\u00eda de Mapbox spritezero-cli , de la siguiente manera: 1 2 3 4 cd ~/Desktop/taller-vt/datos npm install -g @mapbox/spritezero-cli spritezero sprite iconos-maki-svg spritezero --retina sprite@2x iconos-maki-svg Una vez generados, los movemos al directorio donde residir\u00e1 el estilo que los use (en nuestro caso, natural-earth ): 1 2 mkdir ../tileserver/styles/natural-earth mv sprite* ../tileserver/styles/natural-earth Glyphs En la propiedad glyphs se indica una plantilla de URL para cargar glyphs codificados en PBF (el formato es distinto que MVT, ya que el .proto utilizado es distinto), que se usar\u00e1n para dibujar textos en el mapa. Por ejemplo: 1 2 3 4 { ... glyphs : http://localhost:8081/fonts/{fontstack}/{range}.pbf } Esta plantilla de URL debe incluir dos tokens: {fontstack} es el nombre de la tipograf\u00eda. Por ejemplo Open Sans Bold . {range} es un rango de 256 puntos de c\u00f3digo Unicode (es decir, un subconjunto de letras o s\u00edmbolos). En funci\u00f3n del texto a mostrar, el visor solicitar\u00e1 los rangos necesarios. El primero es 0-255 . Una petici\u00f3n real tendr\u00eda la forma: http://localhost:8081/fonts/Open%20Sans%20Bold/0-255.pbf Un glyph contiene una derivada de la tipograf\u00eda binaria llamada signed distance field que permite escalarla sin el pixelado. Una composici\u00f3n de varios glyphs dar\u00eda una imagen con este aspecto: C\u00f3mo crear tus propios glyphs Descargar el proyecto de github openmaptiles/fonts 1 2 3 4 5 6 cd ~/Desktop/taller-vt/ wget https://github.com/openmaptiles/fonts/archive/master.zip unzip master.zip cd fonts-master npm install node generate.js Al cabo de un rato, podemos ver los resultados en el directorio _output . Si no queremos generar una tipograf\u00eda determinada, basta con borrar el directorio que la contiene. Del mismo modo podemos a\u00f1adir tipograf\u00edas a\u00f1adiendo nuevos directorios y copiando dentro las tipograf\u00edas en formato TTF. Por ejemplo, para generar \"Comic Sans\": 1 2 3 rm -rf metropolis noto-sans open-sans pt-sans roboto cp -r ../datos/comic-sans-ms . node generate.js El directorio _output no se borra entre ejecuciones, con lo que habremos conservado todas las fuentes anteriores, adem\u00e1s de la reci\u00e9n generada \"Comic Sans\". Finalmente, copiaremos el contenido de _output al directorio tileserver/fonts : 1 \\c p -r _output/* ../tileserver/fonts Para que el tileserver publique estos recursos, hay que a\u00f1adir una propiedad a tileserver/config.json : 1 2 3 4 5 6 7 8 9 10 11 12 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data }, serveAllFonts : true }, ... } Reiniciando el tileserver para que cargue las nuevas tipograf\u00edas, podemos ver la lista de las tipograf\u00edas disponibles en la direcci\u00f3n http://localhost:8081/fonts.json Ejercicio extra: Generar una tipograf\u00eda a partir de un conjunto de iconos en SVG Si queremos disponer de una colecci\u00f3n de iconos monocrom\u00e1ticos de forma m\u00e1s flexible que usando sprites, los podemos convertir en una tipograf\u00eda. Esto permitir\u00e1 aplicar las t\u00e9cnicas de las etiquetas de texto a nuestros s\u00edmbolos, como escalarlos sin apreciar pixelado, cambiar su color de base, a\u00f1adir un halo, etc. Para transformar un conjunto de iconos SVG en una fuente se pueden utilizar diferentes programas. Aqui un listado de algunas webs que permiten generar fuentes: https://icomoon.io http://fontello.com/ https://glyphter.com/ http://fontastic.me/ Tambi\u00e9n podemos generar una fuente propia utilizando el repositorio https://github.com/gencat/ICGC-fonticon-generator , de la siguiente manera: 1 2 3 4 5 6 cd ~/Desktop/taller-vt git clone https://github.com/gencat/ICGC-fonticon-generator npm i -g gulp cd ICGC-fonticon-generator/ npm install gulp iconfont Una vez generada la fuente, que encontraremos en iconfont/Geostart-Regular.ttf , podemos generar los glyphs como se ha explicado en el apartado anterior, y a\u00f1adirlos al tileserver.","title":"Sprites y Glyphs"},{"location":"5_sprites_glyphs/#sprites-y-glyphs","text":"","title":"Sprites y Glyphs"},{"location":"5_sprites_glyphs/#sprites","text":"Definici\u00f3n Un sprite es una imagen individual que contiene todos los iconos incluidos en un estilo. Al combinar muchas im\u00e1genes peque\u00f1as en una sola imagen (sprite), se puede reducir el n\u00famero de solicitudes necesarias para recuperar todas las im\u00e1genes, mejorar el rendimiento y hacer que el mapa sea m\u00e1s r\u00e1pido. Los Sprites pueden tener un tama\u00f1o m\u00e1ximo de 1024x1024 p\u00edxeles (o 2048x2048 para pantallas con alta DPI). Cada sprite viene acompa\u00f1ado de un archivo JSON donde se define el nombre de cada icono, y su posici\u00f3n y tama\u00f1o para saber c\u00f3mo \"recortarlo\" de la imagen com\u00fan. M\u00e1s informaci\u00f3n en sobre sprites https://www.mapbox.com/help/define-sprite/ Cada uno de los iconos contenidos en un sprite se puede usar como textura para el fondo del mapa, patr\u00f3n de relleno para un pol\u00edgono, patr\u00f3n de dibujo para una l\u00ednea, o una imagen de icono (s\u00edmbolo puntual). La propiedad sprite de un estilo apunta a una URL incompleta , a partir de la cual se pueden encontrar los diferentes ficheros (sprites y json complementario). Por ejemplo, si en el style.json se indica: 1 2 3 4 { ... sprite : http://localhost:8081/styles/osm-bright/sprite } En realidad dicha URL no existe. Pero s\u00ed existen los siguientes recursos (a\u00f1adiendo .png , .json , @2x.png y @2x.json respectivamente): http://localhost:8081/styles/osm-bright/sprite.png Sprite a resoluci\u00f3n convencional http://localhost:8081/styles/osm-bright/sprite.json JSON que define cada icono dentro del sprite http://localhost:8081/styles/osm-bright/sprite@2x.png Sprite a resoluci\u00f3n doble (para pantallas Retina) http://localhost:8081/styles/osm-bright/sprite@2x.json JSON que define cada icono dentro del sprite de resoluci\u00f3n doble Ejemplo de sprite: Uno de los elementos definidos en el JSON: 1 2 3 4 5 6 7 8 9 10 11 { ... airport_11 : { height : 17 , width : 17 , x : 17 , y : 0 , pixelRatio : 1 }, .... }","title":"Sprites"},{"location":"5_sprites_glyphs/#como-crear-tus-propios-sprites","text":"Para generar los sprites a partir de im\u00e1genes individuales hay que crear los cuatro archivos. Esto se podr\u00eda hacer manualmente con un editor de texto, un editor de im\u00e1genes y mucha paciencia, pero afortunadamente existen herramientas que lo automatizan. Los sprites convencionales para la web difieren de los de Mapbox, ya que utilizan una imagen compuesta png y un archivo css con las reglas de simbolizaci\u00f3n para su aprovechamiento en p\u00e1ginas web. Mapbox GL, en cambio, necesita el fichero json , no un CSS. Para generar los sprites y sus json a partir de una colecci\u00f3n de im\u00e1genes en formato SVG, se recomienda el uso de la librer\u00eda de Mapbox spritezero-cli , de la siguiente manera: 1 2 3 4 cd ~/Desktop/taller-vt/datos npm install -g @mapbox/spritezero-cli spritezero sprite iconos-maki-svg spritezero --retina sprite@2x iconos-maki-svg Una vez generados, los movemos al directorio donde residir\u00e1 el estilo que los use (en nuestro caso, natural-earth ): 1 2 mkdir ../tileserver/styles/natural-earth mv sprite* ../tileserver/styles/natural-earth","title":"C\u00f3mo crear tus propios sprites"},{"location":"5_sprites_glyphs/#glyphs","text":"En la propiedad glyphs se indica una plantilla de URL para cargar glyphs codificados en PBF (el formato es distinto que MVT, ya que el .proto utilizado es distinto), que se usar\u00e1n para dibujar textos en el mapa. Por ejemplo: 1 2 3 4 { ... glyphs : http://localhost:8081/fonts/{fontstack}/{range}.pbf } Esta plantilla de URL debe incluir dos tokens: {fontstack} es el nombre de la tipograf\u00eda. Por ejemplo Open Sans Bold . {range} es un rango de 256 puntos de c\u00f3digo Unicode (es decir, un subconjunto de letras o s\u00edmbolos). En funci\u00f3n del texto a mostrar, el visor solicitar\u00e1 los rangos necesarios. El primero es 0-255 . Una petici\u00f3n real tendr\u00eda la forma: http://localhost:8081/fonts/Open%20Sans%20Bold/0-255.pbf Un glyph contiene una derivada de la tipograf\u00eda binaria llamada signed distance field que permite escalarla sin el pixelado. Una composici\u00f3n de varios glyphs dar\u00eda una imagen con este aspecto:","title":"Glyphs"},{"location":"5_sprites_glyphs/#como-crear-tus-propios-glyphs","text":"Descargar el proyecto de github openmaptiles/fonts 1 2 3 4 5 6 cd ~/Desktop/taller-vt/ wget https://github.com/openmaptiles/fonts/archive/master.zip unzip master.zip cd fonts-master npm install node generate.js Al cabo de un rato, podemos ver los resultados en el directorio _output . Si no queremos generar una tipograf\u00eda determinada, basta con borrar el directorio que la contiene. Del mismo modo podemos a\u00f1adir tipograf\u00edas a\u00f1adiendo nuevos directorios y copiando dentro las tipograf\u00edas en formato TTF. Por ejemplo, para generar \"Comic Sans\": 1 2 3 rm -rf metropolis noto-sans open-sans pt-sans roboto cp -r ../datos/comic-sans-ms . node generate.js El directorio _output no se borra entre ejecuciones, con lo que habremos conservado todas las fuentes anteriores, adem\u00e1s de la reci\u00e9n generada \"Comic Sans\". Finalmente, copiaremos el contenido de _output al directorio tileserver/fonts : 1 \\c p -r _output/* ../tileserver/fonts Para que el tileserver publique estos recursos, hay que a\u00f1adir una propiedad a tileserver/config.json : 1 2 3 4 5 6 7 8 9 10 11 12 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data }, serveAllFonts : true }, ... } Reiniciando el tileserver para que cargue las nuevas tipograf\u00edas, podemos ver la lista de las tipograf\u00edas disponibles en la direcci\u00f3n http://localhost:8081/fonts.json","title":"C\u00f3mo crear tus propios glyphs"},{"location":"5_sprites_glyphs/#ejercicio-extra-generar-una-tipografia-a-partir-de-un-conjunto-de-iconos-en-svg","text":"Si queremos disponer de una colecci\u00f3n de iconos monocrom\u00e1ticos de forma m\u00e1s flexible que usando sprites, los podemos convertir en una tipograf\u00eda. Esto permitir\u00e1 aplicar las t\u00e9cnicas de las etiquetas de texto a nuestros s\u00edmbolos, como escalarlos sin apreciar pixelado, cambiar su color de base, a\u00f1adir un halo, etc. Para transformar un conjunto de iconos SVG en una fuente se pueden utilizar diferentes programas. Aqui un listado de algunas webs que permiten generar fuentes: https://icomoon.io http://fontello.com/ https://glyphter.com/ http://fontastic.me/ Tambi\u00e9n podemos generar una fuente propia utilizando el repositorio https://github.com/gencat/ICGC-fonticon-generator , de la siguiente manera: 1 2 3 4 5 6 cd ~/Desktop/taller-vt git clone https://github.com/gencat/ICGC-fonticon-generator npm i -g gulp cd ICGC-fonticon-generator/ npm install gulp iconfont Una vez generada la fuente, que encontraremos en iconfont/Geostart-Regular.ttf , podemos generar los glyphs como se ha explicado en el apartado anterior, y a\u00f1adirlos al tileserver.","title":"Ejercicio extra: Generar una tipograf\u00eda a partir de un conjunto de iconos en SVG"},{"location":"6_estilos/","text":"C\u00f3mo simbolizar teselas vectoriales Maputnik Es un editor visual gratuito y abierto para estilos Mapbox GL dirigidos tanto a desarrolladores como a dise\u00f1adores de mapas. Se puede utilizar en l\u00ednea en Maputnik editor o se puede hacer una instalaci\u00f3n local. Instalaci\u00f3n Se puede descargar la \u00faltima versi\u00f3n de la p\u00e1gina de releases . En nuestro caso, la tenemos ya descargada en ~/Desktop/taller-vt/maputnik . Para arrancar la versi\u00f3n local: 1 2 cd ~/Desktop/taller-vt/maputnik live-server --port = 8082 Abrir Maputnik en http://localhost:8082 Comenzar un estilo nuevo En la barra de men\u00fa seleccionamos la opci\u00f3n Open . Del apartado Gallery Styles , seleccionamos Empty Style . Agregar un origen de datos (Source) En la barra de men\u00fa seleccionamos la opci\u00f3n Sources . En la parte inferior del di\u00e1logo est\u00e1 la secci\u00f3n: Add New Source . Como Source ID ponemos naturalearth . Como Source Type seleccionamos Vector (TileJSON URL) . Como TileJSON URL seleccionamos http://localhost:8081/data/natural_earth.json Tambi\u00e9n se podr\u00eda usar como Source Type un Vector (XYZ URL) , en cuyo caso tambi\u00e9n hay que indicar el rango de zooms en que los datos son v\u00e1lidos. Agregar sprite y glyphs En la barra de men\u00fa seleccionamos Style Settings : Name : Nombre del estilo. En nuestro caso pondremos Natural Earth . Sprite URL : Usaremos el sprite de uno de los estilos que tenemos publicados en tileserver http://localhost:8081/styles/osm-bright/sprite Glyphs URL : Accederemos a las tipograf\u00edas publicadas en nuestro Tileserver http://localhost:8081/fonts/{fontstack}/{range}.pbf Simbolizaci\u00f3n b\u00e1sica Presionamos el bot\u00f3n de Add Layer : Fondo A\u00f1adimos una primera capa de fondo: ID : identificador \u00fanico de la capa. Pondremos fondo . Type : tipo de capa. Seleccionar la opci\u00f3n de Background . Seleccionamos el color en Paint properties = Color : \"#F8F4F0\". El fondo del mapa pasa a un gris claro. Oc\u00e9anos A\u00f1adimos ahora los oc\u00e9anos: ID : identificador \u00fanico de la capa. Pondremos oceanos . Type : tipo de capa. Seleccionar la opci\u00f3n de Fill ya que la capa es de tipo pol\u00edgono. Source : identificador del origen de datos. En nuestro caso pondremos naturalearth . Source Layer : identificador de la capa dentro del origen de datos. Pondremos ocean . Aparecer\u00e1n los oc\u00e9anos de color negro. Simbolizamos la capa seleccionando un color RGB en Paint properties = Color : \"#A0C8F0\". En el apartado inferior del panel de propiedades de la capa, vamos viendo la definici\u00f3n tal como se guardar\u00e1 en el fichero json de estilo: 1 2 3 4 5 6 7 8 9 { id : oceanos , type : fill , source : naturalearth , source-layer : ocean , paint : { fill-color : #A0C8F0 } } Maputnik no es m\u00e1s que un asistente gr\u00e1fico para generar el fichero style.json . Resto de capas b\u00e1sicas El resto de capas se puede simbolizar procediendo de la misma manera: id type source-layer color otras propiedades \"paint\" fondo Background -- #F8F4F0 -- oceanos Fill ocean #A0C8F0 -- tierra Fill land #E6C7C7 -- costa Line coastline #4793E8 -- rios Line rivers #4793E8 -- lagos Fill lakes #A0C8F0 Outline color: #4793E8 ferrocarril Line rail #707070 -- carreteras Line roads #BF5757 -- Filtrar los datos a mostrar en una capa Vamos a eliminar las rutas de ferry que se muestran como carreteras. Hay dos maneras de definir un filtro en un estilo MapboxGL: Filters : La forma cl\u00e1sica, que implementa Maputnik: https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter Decision Expressions : La nueva forma, m\u00e1s potente, pero que Maputnik no implementa: https://www.mapbox.com/mapbox-gl-js/style-spec/#expressions-decision Ahora aprenderemos a crear un Filter con Maputnik, y m\u00e1s adelante aplicaremos Expressions directamente sobre el fichero json de estilo. En Maputnik, seleccionando la capa carreteras , apartado Filter : Presionamos el bot\u00f3n Add filter . La condici\u00f3n ser\u00e1: 1 featurecla == Road Comprobar que desaparecen las l\u00edneas de Ferry en el mapa. Tip Usa el Inspect Mode integrado en Maputnik para explorar los diferentes campos de una capa y sus posibles valores. Ejercicio extra Crea una nueva capa \"ferrys\" y aplica el filtro contrario para mostrar s\u00f3lo las rutas de ferry. Investiga la propiedad Dasharray para darle un aspecto de l\u00ednea discontinua a las rutas. Etiquetar una capa Agregar la capa de ciudades. Presionar el bot\u00f3n de Add Layer y rellenar el formulario con la siguiente informaci\u00f3n: ID : ciudades Type : Symbol , utilizado para mostrar entidades puntuales (iconos y etiquetas) Source : naturalearth Source Layer : cities En el apartado Text layout properties : En la propiedad Field escribir {NAME} (el nombre del campo a mostrar, entre llaves). En la propiedad Font , escribir Comic Sans , tipograf\u00eda que hemos generado y publicado en el apartado anterior (nota: el taller sobre c\u00f3mo hacer mapas bonitos es esta tarde). Utilizar un icono para simbolizar nuestra capa Agregar la capa de aeropuertos. Presionar el bot\u00f3n de Add Layer y rellenar el formulario con la siguiente informaci\u00f3n: ID : aeropuertos Type : Symbol , utilizado para mostrar entidades puntuales (iconos y etiquetas) Source : naturalearth Source Layer : airports En el apartado de Icon layout properties : En la propiedad Image , escribir airport_11 . Este nombre debe coincidir con alguna imagen definida en el sprite. Comprobar que aparecen los aeropuertos en el mapa. Tip Estos son los iconos del sprite del estilo ( osm-bright ) que estamos utilizando: https://github.com/openmaptiles/osm-bright-gl-style/tree/master/icons Exportar el estilo creado Seleccionar la opci\u00f3n Export , y luego el boton de Download para descargar el estilo en nuestro ordenador. Descargamos el archivo, lo renombramos a style.json y lo movemos a la carpeta tileserver/styles/natural-earth/ , donde ya hab\u00edamos copiado los sprites generados en el apartado anterior. 1 cp ~/Downloads/xxxxxx.json ~/Desktop/taller-vt/tileserver/styles/natural-earth/style.json Habr\u00e1 que editar el fichero de configuraci\u00f3n de tileserver tileserver/config.json para a\u00f1adir el estilo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, natural-earth : { style : natural-earth/style.json } } Reiniciar tileserver y comprobar que ofrece el nuevo estilo de visualizaci\u00f3n. Edici\u00f3n manual del estilo Vamos a dejar Maputnik a un lado y vamos a editar el estilo json a mano. Crear un visor para el nuevo estilo Lo primero ser\u00e1 crear un visor para los datos y estilo de Natural Earth partiendo del visor de Barcelona. Tambi\u00e9n usaremos una copia local del estilo porque ser\u00e1 m\u00e1s f\u00e1cil ir viendo los cambios. Cada vez que guardemos en disco una modificaci\u00f3n del fichero de estilo, podremos recargar directamente la p\u00e1gina en el navegador para reflejar los cambios. Copiar el archivo visor/barcelona.html en visor/naturalearth.html Adem\u00e1s, hacer una copia de tileserver/styles/natural-earth/style.json en visor/natural-earth-style.json . Editaremos visor/naturalearth.html y en la parte de script dejaremos s\u00f3lo este c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 var map = new mapboxgl . Map ({ container : map , style : natural-earth-style.json , center : [ 1.5 , 41 ], zoom : 5 , hash : true }); map . addControl ( new mapboxgl . NavigationControl ()); map . addControl ( new MapboxInspect ()); Abriendo en el navegador http://127.0.0.1:8080/naturalearth.html deber\u00eda verse: Estilo avanzado basado en expresiones El estilo basado en datos permite estilizar los datos en funci\u00f3n del valor de sus propiedades. Por ejemplo, cambiar el radio de un c\u00edrculo o el color de un pol\u00edgono en funci\u00f3n de un valor num\u00e9rico, o usar l\u00f3gica condicional para crear etiquetas multiling\u00fces. Las expresiones de Mapbox GL se pueden usar en cualquier propiedad de tipo layout , paint o filter de una layer . Gracias a las expresiones, una regla de simbolizaci\u00f3n determinada puede calcularse como el resultado de un c\u00e1lculo donde intervienen los valores de una o m\u00e1s propiedades de una feature . Pueden usarse operaciones l\u00f3gicas, matem\u00e1ticas, de generaci\u00f3n de color, interpolaciones, etc. Estilo basado en valores concretos de una propiedad Abrir el fichero natural-earth-style.json y localizar el layer con id carreteras . Vamos a asignar un color distinto en funci\u00f3n del valor de la propiedad type . Para ello usaremos la expresi\u00f3n Match , que asigna a cada valor de entrada un valor de salida distinto (en nuestro caso, un color para cada tipo de carretera): 1 2 3 4 5 6 [ match , lt;propiedad gt;, lt;valorentrada_1 gt;, lt;salida_1 gt;, lt;entrada_2 gt;, lt;salida_2 gt;, ..., lt;salida_por_defecto gt; ] Para obtener el valor de la propiedad de una feature se usa la expresi\u00f3n Get: [\"get\", nombre_propiedad ] . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { id : carreteras , type : line , source : naturalearth , source-layer : roads , filter : [ all , [ == , featurecla , Road ]], paint : { line-color : [ match , [ get , type ], Major Highway , rgba(20, 52, 232, 1) , Secondary Highway , rgba(206, 32, 79, 1) , Road , rgba(49, 137, 52, 1) , rgba(255, 204, 0, 1) ], line-width : 2 } } Estilo basado en el nivel del zoom Localizar el layer con id ciudades . Vamos a cambiar el tama\u00f1o del texto seg\u00fan el nivel de zoom del mapa, y de la propiedad SCALERANK del dato. Usaremos la expresi\u00f3n Case , que tiene esta forma: 1 2 3 4 5 6 [ case , lt;condicion_1 gt;, lt;salida_1 gt;, lt;condicion_2 gt;, lt;salida_2 gt;, ..., lt;salida_por_defecto gt; ] En nuestro caso la usaremos para decir cosas como: Si \"SCALERANK\" es menor que 2, aplica un tama\u00f1o de letra 20, Si \"SCALERANK\" est\u00e1 entre 3 y 5, aplica un tama\u00f1o de letra 14, En cualquier otro caso, aplica un tama\u00f1o de letra 10 Que quedar\u00eda expresado as\u00ed: 1 2 3 4 5 6 [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 20 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 14 , 10 ] El operador \"number\" se usa para convertir el valor SCALERANK a un tipo num\u00e9rico. Y la combinaremos con la expresi\u00f3n Step , que tiene esta forma: 1 2 3 4 5 6 [ step , lt;entrada gt;, lt;salida_inicial gt;, lt;umbral_1 gt;, lt;salida_1 gt;, lt;umbral_2 gt;, lt;salida_2 gt;, ... ] En nuestro caso la podemos usar para decir cosas como: Usa un tama\u00f1o de letra 18 para zooms por debajo de 5. Usa un tama\u00f1o de letra 20 entre el zoom 5 y 8. Usa un tama\u00f1o de letra 24 para zooms mayores que 8. Que quedar\u00eda: 1 2 3 4 5 [ step , [ zoom ], 18 , 5 , 20 , 8 , 24 ] Obviamente podemos combinar ambas expresiones, de forma que la salida para cada nivel de zoom no sea un tama\u00f1o de letra concreto, sino que dependa de \"SCALERANK\". Y nos queda el siguiente monstruo para el Layer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { id : ciudades , type : symbol , source : naturalearth , source-layer : cities , layout : { text-field : {NAME} , text-anchor : bottom , text-offset : [ 0 , -1 ], text-size : [ step , [ zoom ], [ case , [ , [ number , [ get , SCALERANK ]], 3 ], 18 , 0 ], 5 , [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 20 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 14 , 10 ], 8 , [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 24 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 18 , 14 ] ] }, paint : { text-halo-color : rgba(253, 253, 253, 1) , text-color : rgba(16, 16, 16, 1) , text-halo-width : 1.5 } } Como se puede observar, las expresiones son tan potentes como dif\u00edciles de escribir bien a la primera. Estilo basado en una propiedad Vamos a crear un nuevo layer llamado ciudades-circle , y la vamos a definir a continuaci\u00f3n de ciudades y justo antes de aeropuertos . Dibujaremos un c\u00edrculo cuyo tama\u00f1o ser\u00e1 inversamente proporcional a la propiedad SCALERANK . Adem\u00e1s, las capitales estatales se simbolizar\u00e1n como un c\u00edrculo blanco con un borde grueso, y el resto de ciudades con un c\u00edrculo gris con borde m\u00e1s fino. Usaremos la misma expresi\u00f3n Match que hemos visto anteriormente, aplicada a un color y a un grueso de l\u00ednea. Adem\u00e1s, aplicaremos una expresi\u00f3n matem\u00e1tica [\"-\"] , que resta dos valores, de manera que el tama\u00f1o del c\u00edrculo ser\u00e1 10 - SCALERANK : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { id : ciudades-circle , type : circle , source : naturalearth , source-layer : cities , paint : { circle-color : [ match , [ get , ADM0CAP ], 0 , #888 , #FFF ], circle-stroke-width : [ match , [ get , ADM0CAP ], 0 , 1 , 2 ], circle-radius : [ - , 10 , [ get , SCALERANK ]] } } Uso de fuentes de datos externas Por \u00faltimo, vamos a a\u00f1adir un fondo raster al mapa, procedente de otro tileserver. A\u00f1adiremos un nuevo source de tipo raster , a continuaci\u00f3n del source naturalearth : 1 2 3 4 5 6 7 8 9 10 11 12 sources : { naturalearth : { type : vector , url : http://localhost:8081/data/natural_earth.json }, relief : { type : raster , tiles : [ http://naturalearthtiles.lukasmartinelli.ch/tiles/natural_earth_2_shaded_relief.raster/{z}/{x}/{y}.png ], tileSize : 256 , maxzoom : 6 } } Borraremos el layer llamado tierra . A\u00f1adiremos un nuevo layer justo despu\u00e9s del fondo que se llamar\u00e1 terreno : 1 2 3 4 5 { id : terreno , type : raster , source : relief } El resultado final de aplicar todos estos estilos tendr\u00e1 este aspecto: Ejercicio extra: uso de una fuente con iconos para simbolizar un punto Si se ha hecho el ejercicio extra del apartado anterior, en el que cre\u00e1bamos una fuente a partir de una colecci\u00f3n de iconos, ahora veremos c\u00f3mo utilizarla en el Layer de aeropuertos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { id : aeropuertos , type : symbol , source : naturalearth , source-layer : airports , layout : { icon-image : , text-font : [ Geostart Regular ], text-size : 25 , text-field : , }, paint : { text-color : #fabada , text-halo-color : #888 , text-halo-width : 2 } } En las l\u00edneas destacadas se observa c\u00f3mo no se usa una icon-image , sino una etiqueta de texto ( text-font , text-size y text-field ). En text-field se indica una coma \",\" , que corresponde al icono que queremos mostrar. Al tratarse de una fuente, podemos indicar el tama\u00f1o que queramos sin miedo a obtener una imagen pixelada, y aplicar otras propiedades como escoger color, halo, etc. Como resultado del estilo indicado se simbolizar\u00edan los aeropuertos as\u00ed:","title":"C\u00f3mo simbolizar teselas vectoriales"},{"location":"6_estilos/#como-simbolizar-teselas-vectoriales","text":"","title":"C\u00f3mo simbolizar teselas vectoriales"},{"location":"6_estilos/#maputnik","text":"Es un editor visual gratuito y abierto para estilos Mapbox GL dirigidos tanto a desarrolladores como a dise\u00f1adores de mapas. Se puede utilizar en l\u00ednea en Maputnik editor o se puede hacer una instalaci\u00f3n local.","title":"Maputnik"},{"location":"6_estilos/#instalacion","text":"Se puede descargar la \u00faltima versi\u00f3n de la p\u00e1gina de releases . En nuestro caso, la tenemos ya descargada en ~/Desktop/taller-vt/maputnik . Para arrancar la versi\u00f3n local: 1 2 cd ~/Desktop/taller-vt/maputnik live-server --port = 8082 Abrir Maputnik en http://localhost:8082","title":"Instalaci\u00f3n"},{"location":"6_estilos/#comenzar-un-estilo-nuevo","text":"En la barra de men\u00fa seleccionamos la opci\u00f3n Open . Del apartado Gallery Styles , seleccionamos Empty Style .","title":"Comenzar un estilo nuevo"},{"location":"6_estilos/#agregar-un-origen-de-datos-source","text":"En la barra de men\u00fa seleccionamos la opci\u00f3n Sources . En la parte inferior del di\u00e1logo est\u00e1 la secci\u00f3n: Add New Source . Como Source ID ponemos naturalearth . Como Source Type seleccionamos Vector (TileJSON URL) . Como TileJSON URL seleccionamos http://localhost:8081/data/natural_earth.json Tambi\u00e9n se podr\u00eda usar como Source Type un Vector (XYZ URL) , en cuyo caso tambi\u00e9n hay que indicar el rango de zooms en que los datos son v\u00e1lidos.","title":"Agregar un origen de datos (Source)"},{"location":"6_estilos/#agregar-sprite-y-glyphs","text":"En la barra de men\u00fa seleccionamos Style Settings : Name : Nombre del estilo. En nuestro caso pondremos Natural Earth . Sprite URL : Usaremos el sprite de uno de los estilos que tenemos publicados en tileserver http://localhost:8081/styles/osm-bright/sprite Glyphs URL : Accederemos a las tipograf\u00edas publicadas en nuestro Tileserver http://localhost:8081/fonts/{fontstack}/{range}.pbf","title":"Agregar sprite y glyphs"},{"location":"6_estilos/#simbolizacion-basica","text":"Presionamos el bot\u00f3n de Add Layer :","title":"Simbolizaci\u00f3n b\u00e1sica"},{"location":"6_estilos/#fondo","text":"A\u00f1adimos una primera capa de fondo: ID : identificador \u00fanico de la capa. Pondremos fondo . Type : tipo de capa. Seleccionar la opci\u00f3n de Background . Seleccionamos el color en Paint properties = Color : \"#F8F4F0\". El fondo del mapa pasa a un gris claro.","title":"Fondo"},{"location":"6_estilos/#oceanos","text":"A\u00f1adimos ahora los oc\u00e9anos: ID : identificador \u00fanico de la capa. Pondremos oceanos . Type : tipo de capa. Seleccionar la opci\u00f3n de Fill ya que la capa es de tipo pol\u00edgono. Source : identificador del origen de datos. En nuestro caso pondremos naturalearth . Source Layer : identificador de la capa dentro del origen de datos. Pondremos ocean . Aparecer\u00e1n los oc\u00e9anos de color negro. Simbolizamos la capa seleccionando un color RGB en Paint properties = Color : \"#A0C8F0\". En el apartado inferior del panel de propiedades de la capa, vamos viendo la definici\u00f3n tal como se guardar\u00e1 en el fichero json de estilo: 1 2 3 4 5 6 7 8 9 { id : oceanos , type : fill , source : naturalearth , source-layer : ocean , paint : { fill-color : #A0C8F0 } } Maputnik no es m\u00e1s que un asistente gr\u00e1fico para generar el fichero style.json .","title":"Oc\u00e9anos"},{"location":"6_estilos/#resto-de-capas-basicas","text":"El resto de capas se puede simbolizar procediendo de la misma manera: id type source-layer color otras propiedades \"paint\" fondo Background -- #F8F4F0 -- oceanos Fill ocean #A0C8F0 -- tierra Fill land #E6C7C7 -- costa Line coastline #4793E8 -- rios Line rivers #4793E8 -- lagos Fill lakes #A0C8F0 Outline color: #4793E8 ferrocarril Line rail #707070 -- carreteras Line roads #BF5757 --","title":"Resto de capas b\u00e1sicas"},{"location":"6_estilos/#filtrar-los-datos-a-mostrar-en-una-capa","text":"Vamos a eliminar las rutas de ferry que se muestran como carreteras. Hay dos maneras de definir un filtro en un estilo MapboxGL: Filters : La forma cl\u00e1sica, que implementa Maputnik: https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter Decision Expressions : La nueva forma, m\u00e1s potente, pero que Maputnik no implementa: https://www.mapbox.com/mapbox-gl-js/style-spec/#expressions-decision Ahora aprenderemos a crear un Filter con Maputnik, y m\u00e1s adelante aplicaremos Expressions directamente sobre el fichero json de estilo. En Maputnik, seleccionando la capa carreteras , apartado Filter : Presionamos el bot\u00f3n Add filter . La condici\u00f3n ser\u00e1: 1 featurecla == Road Comprobar que desaparecen las l\u00edneas de Ferry en el mapa. Tip Usa el Inspect Mode integrado en Maputnik para explorar los diferentes campos de una capa y sus posibles valores.","title":"Filtrar los datos a mostrar en una capa"},{"location":"6_estilos/#ejercicio-extra","text":"Crea una nueva capa \"ferrys\" y aplica el filtro contrario para mostrar s\u00f3lo las rutas de ferry. Investiga la propiedad Dasharray para darle un aspecto de l\u00ednea discontinua a las rutas.","title":"Ejercicio extra"},{"location":"6_estilos/#etiquetar-una-capa","text":"Agregar la capa de ciudades. Presionar el bot\u00f3n de Add Layer y rellenar el formulario con la siguiente informaci\u00f3n: ID : ciudades Type : Symbol , utilizado para mostrar entidades puntuales (iconos y etiquetas) Source : naturalearth Source Layer : cities En el apartado Text layout properties : En la propiedad Field escribir {NAME} (el nombre del campo a mostrar, entre llaves). En la propiedad Font , escribir Comic Sans , tipograf\u00eda que hemos generado y publicado en el apartado anterior (nota: el taller sobre c\u00f3mo hacer mapas bonitos es esta tarde).","title":"Etiquetar una capa"},{"location":"6_estilos/#utilizar-un-icono-para-simbolizar-nuestra-capa","text":"Agregar la capa de aeropuertos. Presionar el bot\u00f3n de Add Layer y rellenar el formulario con la siguiente informaci\u00f3n: ID : aeropuertos Type : Symbol , utilizado para mostrar entidades puntuales (iconos y etiquetas) Source : naturalearth Source Layer : airports En el apartado de Icon layout properties : En la propiedad Image , escribir airport_11 . Este nombre debe coincidir con alguna imagen definida en el sprite. Comprobar que aparecen los aeropuertos en el mapa. Tip Estos son los iconos del sprite del estilo ( osm-bright ) que estamos utilizando: https://github.com/openmaptiles/osm-bright-gl-style/tree/master/icons","title":"Utilizar un icono para simbolizar nuestra capa"},{"location":"6_estilos/#exportar-el-estilo-creado","text":"Seleccionar la opci\u00f3n Export , y luego el boton de Download para descargar el estilo en nuestro ordenador. Descargamos el archivo, lo renombramos a style.json y lo movemos a la carpeta tileserver/styles/natural-earth/ , donde ya hab\u00edamos copiado los sprites generados en el apartado anterior. 1 cp ~/Downloads/xxxxxx.json ~/Desktop/taller-vt/tileserver/styles/natural-earth/style.json Habr\u00e1 que editar el fichero de configuraci\u00f3n de tileserver tileserver/config.json para a\u00f1adir el estilo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, natural-earth : { style : natural-earth/style.json } } Reiniciar tileserver y comprobar que ofrece el nuevo estilo de visualizaci\u00f3n.","title":"Exportar el estilo creado"},{"location":"6_estilos/#edicion-manual-del-estilo","text":"Vamos a dejar Maputnik a un lado y vamos a editar el estilo json a mano.","title":"Edici\u00f3n manual del estilo"},{"location":"6_estilos/#crear-un-visor-para-el-nuevo-estilo","text":"Lo primero ser\u00e1 crear un visor para los datos y estilo de Natural Earth partiendo del visor de Barcelona. Tambi\u00e9n usaremos una copia local del estilo porque ser\u00e1 m\u00e1s f\u00e1cil ir viendo los cambios. Cada vez que guardemos en disco una modificaci\u00f3n del fichero de estilo, podremos recargar directamente la p\u00e1gina en el navegador para reflejar los cambios. Copiar el archivo visor/barcelona.html en visor/naturalearth.html Adem\u00e1s, hacer una copia de tileserver/styles/natural-earth/style.json en visor/natural-earth-style.json . Editaremos visor/naturalearth.html y en la parte de script dejaremos s\u00f3lo este c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 var map = new mapboxgl . Map ({ container : map , style : natural-earth-style.json , center : [ 1.5 , 41 ], zoom : 5 , hash : true }); map . addControl ( new mapboxgl . NavigationControl ()); map . addControl ( new MapboxInspect ()); Abriendo en el navegador http://127.0.0.1:8080/naturalearth.html deber\u00eda verse:","title":"Crear un visor para el nuevo estilo"},{"location":"6_estilos/#estilo-avanzado-basado-en-expresiones","text":"El estilo basado en datos permite estilizar los datos en funci\u00f3n del valor de sus propiedades. Por ejemplo, cambiar el radio de un c\u00edrculo o el color de un pol\u00edgono en funci\u00f3n de un valor num\u00e9rico, o usar l\u00f3gica condicional para crear etiquetas multiling\u00fces. Las expresiones de Mapbox GL se pueden usar en cualquier propiedad de tipo layout , paint o filter de una layer . Gracias a las expresiones, una regla de simbolizaci\u00f3n determinada puede calcularse como el resultado de un c\u00e1lculo donde intervienen los valores de una o m\u00e1s propiedades de una feature . Pueden usarse operaciones l\u00f3gicas, matem\u00e1ticas, de generaci\u00f3n de color, interpolaciones, etc.","title":"Estilo avanzado basado en expresiones"},{"location":"6_estilos/#estilo-basado-en-valores-concretos-de-una-propiedad","text":"Abrir el fichero natural-earth-style.json y localizar el layer con id carreteras . Vamos a asignar un color distinto en funci\u00f3n del valor de la propiedad type . Para ello usaremos la expresi\u00f3n Match , que asigna a cada valor de entrada un valor de salida distinto (en nuestro caso, un color para cada tipo de carretera): 1 2 3 4 5 6 [ match , lt;propiedad gt;, lt;valorentrada_1 gt;, lt;salida_1 gt;, lt;entrada_2 gt;, lt;salida_2 gt;, ..., lt;salida_por_defecto gt; ] Para obtener el valor de la propiedad de una feature se usa la expresi\u00f3n Get: [\"get\", nombre_propiedad ] . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { id : carreteras , type : line , source : naturalearth , source-layer : roads , filter : [ all , [ == , featurecla , Road ]], paint : { line-color : [ match , [ get , type ], Major Highway , rgba(20, 52, 232, 1) , Secondary Highway , rgba(206, 32, 79, 1) , Road , rgba(49, 137, 52, 1) , rgba(255, 204, 0, 1) ], line-width : 2 } }","title":"Estilo basado en valores concretos de una propiedad"},{"location":"6_estilos/#estilo-basado-en-el-nivel-del-zoom","text":"Localizar el layer con id ciudades . Vamos a cambiar el tama\u00f1o del texto seg\u00fan el nivel de zoom del mapa, y de la propiedad SCALERANK del dato. Usaremos la expresi\u00f3n Case , que tiene esta forma: 1 2 3 4 5 6 [ case , lt;condicion_1 gt;, lt;salida_1 gt;, lt;condicion_2 gt;, lt;salida_2 gt;, ..., lt;salida_por_defecto gt; ] En nuestro caso la usaremos para decir cosas como: Si \"SCALERANK\" es menor que 2, aplica un tama\u00f1o de letra 20, Si \"SCALERANK\" est\u00e1 entre 3 y 5, aplica un tama\u00f1o de letra 14, En cualquier otro caso, aplica un tama\u00f1o de letra 10 Que quedar\u00eda expresado as\u00ed: 1 2 3 4 5 6 [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 20 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 14 , 10 ] El operador \"number\" se usa para convertir el valor SCALERANK a un tipo num\u00e9rico. Y la combinaremos con la expresi\u00f3n Step , que tiene esta forma: 1 2 3 4 5 6 [ step , lt;entrada gt;, lt;salida_inicial gt;, lt;umbral_1 gt;, lt;salida_1 gt;, lt;umbral_2 gt;, lt;salida_2 gt;, ... ] En nuestro caso la podemos usar para decir cosas como: Usa un tama\u00f1o de letra 18 para zooms por debajo de 5. Usa un tama\u00f1o de letra 20 entre el zoom 5 y 8. Usa un tama\u00f1o de letra 24 para zooms mayores que 8. Que quedar\u00eda: 1 2 3 4 5 [ step , [ zoom ], 18 , 5 , 20 , 8 , 24 ] Obviamente podemos combinar ambas expresiones, de forma que la salida para cada nivel de zoom no sea un tama\u00f1o de letra concreto, sino que dependa de \"SCALERANK\". Y nos queda el siguiente monstruo para el Layer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { id : ciudades , type : symbol , source : naturalearth , source-layer : cities , layout : { text-field : {NAME} , text-anchor : bottom , text-offset : [ 0 , -1 ], text-size : [ step , [ zoom ], [ case , [ , [ number , [ get , SCALERANK ]], 3 ], 18 , 0 ], 5 , [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 20 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 14 , 10 ], 8 , [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 24 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 18 , 14 ] ] }, paint : { text-halo-color : rgba(253, 253, 253, 1) , text-color : rgba(16, 16, 16, 1) , text-halo-width : 1.5 } } Como se puede observar, las expresiones son tan potentes como dif\u00edciles de escribir bien a la primera.","title":"Estilo basado en el nivel del zoom"},{"location":"6_estilos/#estilo-basado-en-una-propiedad","text":"Vamos a crear un nuevo layer llamado ciudades-circle , y la vamos a definir a continuaci\u00f3n de ciudades y justo antes de aeropuertos . Dibujaremos un c\u00edrculo cuyo tama\u00f1o ser\u00e1 inversamente proporcional a la propiedad SCALERANK . Adem\u00e1s, las capitales estatales se simbolizar\u00e1n como un c\u00edrculo blanco con un borde grueso, y el resto de ciudades con un c\u00edrculo gris con borde m\u00e1s fino. Usaremos la misma expresi\u00f3n Match que hemos visto anteriormente, aplicada a un color y a un grueso de l\u00ednea. Adem\u00e1s, aplicaremos una expresi\u00f3n matem\u00e1tica [\"-\"] , que resta dos valores, de manera que el tama\u00f1o del c\u00edrculo ser\u00e1 10 - SCALERANK : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { id : ciudades-circle , type : circle , source : naturalearth , source-layer : cities , paint : { circle-color : [ match , [ get , ADM0CAP ], 0 , #888 , #FFF ], circle-stroke-width : [ match , [ get , ADM0CAP ], 0 , 1 , 2 ], circle-radius : [ - , 10 , [ get , SCALERANK ]] } }","title":"Estilo basado en una propiedad"},{"location":"6_estilos/#uso-de-fuentes-de-datos-externas","text":"Por \u00faltimo, vamos a a\u00f1adir un fondo raster al mapa, procedente de otro tileserver. A\u00f1adiremos un nuevo source de tipo raster , a continuaci\u00f3n del source naturalearth : 1 2 3 4 5 6 7 8 9 10 11 12 sources : { naturalearth : { type : vector , url : http://localhost:8081/data/natural_earth.json }, relief : { type : raster , tiles : [ http://naturalearthtiles.lukasmartinelli.ch/tiles/natural_earth_2_shaded_relief.raster/{z}/{x}/{y}.png ], tileSize : 256 , maxzoom : 6 } } Borraremos el layer llamado tierra . A\u00f1adiremos un nuevo layer justo despu\u00e9s del fondo que se llamar\u00e1 terreno : 1 2 3 4 5 { id : terreno , type : raster , source : relief } El resultado final de aplicar todos estos estilos tendr\u00e1 este aspecto:","title":"Uso de fuentes de datos externas"},{"location":"6_estilos/#ejercicio-extra-uso-de-una-fuente-con-iconos-para-simbolizar-un-punto","text":"Si se ha hecho el ejercicio extra del apartado anterior, en el que cre\u00e1bamos una fuente a partir de una colecci\u00f3n de iconos, ahora veremos c\u00f3mo utilizarla en el Layer de aeropuertos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { id : aeropuertos , type : symbol , source : naturalearth , source-layer : airports , layout : { icon-image : , text-font : [ Geostart Regular ], text-size : 25 , text-field : , }, paint : { text-color : #fabada , text-halo-color : #888 , text-halo-width : 2 } } En las l\u00edneas destacadas se observa c\u00f3mo no se usa una icon-image , sino una etiqueta de texto ( text-font , text-size y text-field ). En text-field se indica una coma \",\" , que corresponde al icono que queremos mostrar. Al tratarse de una fuente, podemos indicar el tama\u00f1o que queramos sin miedo a obtener una imagen pixelada, y aplicar otras propiedades como escoger color, halo, etc. Como resultado del estilo indicado se simbolizar\u00edan los aeropuertos as\u00ed:","title":"Ejercicio extra: uso de una fuente con iconos para simbolizar un punto"},{"location":"7_servidor_dinamico/","text":"C\u00f3mo servir datos din\u00e1micos Partiremos de unos datos con los distritos, barrios y secciones censales de Barcelona. Los datos est\u00e1n en datos/bcn_geodata.sql . Note El origen de los datos es Ajuntament de Barcelona CC-by ( http://w20.bcn.cat/cartobcn/ ). Mart\u00edn Gonz\u00e1lez los convirti\u00f3 a GeoJSON ( https://github.com/martgnz/bcn-geodata ). Para el taller los hemos convertido de GeoJSON a PostGIS. Cargarlos en PostGIS: 1 2 cd ~/Desktop/taller-vt psql -U user datos/bcn_geodata.sql Se crear\u00e1 una BDD bcn_geodata con las tablas barrios , distritos y seccion_censal . Se puede acceder a esta BDD con el usuario user , password user . Una vez con los datos cargados en PostGIS, usaremos tegola para levantar un servidor de teselas vectoriales partir de una BDD PostGIS. Instalando Tegola Tegola consiste en un solo fichero ejecutable. La instalaci\u00f3n consiste en descargarse un zip, descomprimirlo, y copiar el fichero ejecutable resultante en una ruta localizable: 1 2 3 wget https://github.com/go-spatial/tegola/releases/download/v0.6.3/tegola_linux_amd64.zip unzip tegola_linux_amd64.zip sudo mv tegola_linux_amd64 /usr/local/bin/tegola Comprobar que puede ejecutarse tegola correctamente, y borrar el zip: 1 2 tegola -h # comprobar instalacion rm tegola_linux_amd64.zip Configurando Tegola Tegola necesita de un fichero de configuraci\u00f3n en formato toml para funcionar. En \u00e9l estableceremos los par\u00e1metros de conexi\u00f3n con la BDD y las caracter\u00edsticas de las capas que queremos servir. Creemos pues un directorio llamado tegola , y en \u00e9l, un fichero llamado config.toml . 1 2 3 mkdir tegola cd tegola touch config.toml Lo primero es definir una secci\u00f3n con el puerto que usaremos para levantar el servicio: 1 2 [webserver] port = :8083 A continuaci\u00f3n definimos la conexi\u00f3n con la BDD en una secci\u00f3n providers . Dentro del provider, definimos las capas de datos que queremos obtener de la BDD. En nuestro caso son muy sencillas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [[providers]] name = postgis type = postgis host = localhost port = 5432 database = bcn_geodata user = user password = user [[providers.layers]] name = distritos tablename = distritos [[providers.layers]] name = barrios tablename = barrios [[providers.layers]] name = seccion_censal tablename = seccion_censal En estas providers.layers tambi\u00e9n se podr\u00edan seleccionar qu\u00e9 columnas queremos obtener, o incluso indicar una consulta SQL para generar la capa, haciendo JOIN de varias tablas, aplicando operaciones espaciales, etc. En nuestro caso, servimos las tablas tal cual. Finalmente, creamos una secci\u00f3n maps , que consiste en un nombre, y una serie de capas de informaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [[maps]] name = bcn_geodata attribution = CC-by Ajuntament de Barcelona center = [2.175, 41.39, 13.0] bounds = [1.898, 41.246, 2.312, 41.533] [[maps.layers]] provider_layer = postgis.seccion_censal dont_simplify = true min_zoom = 11 max_zoom = 16 [[maps.layers]] provider_layer = postgis.barrios dont_simplify = true min_zoom = 10 max_zoom = 16 [[maps.layers]] provider_layer = postgis.distritos dont_simplify = true min_zoom = 0 max_zoom = 16 En estas maps.layers se indican par\u00e1metros para la generaci\u00f3n de las VT, como el rango de niveles de zoom en las que ser\u00e1n visibles, si se simplificar\u00e1 o no la geometr\u00eda. En la configuraci\u00f3n tambi\u00e9n existe la posibilidad de activar una cach\u00e9 en disco, en s3 o en redis, as\u00ed como comandos para invalidar partes de la cach\u00e9. En nuestro caso, no hemos usado cach\u00e9. Arrancando tegola Arrancamos el servicio desde el directorio donde hayamos guardato config.toml : 1 2 ~/Desktop/taller-vt/tegola tegola serve Y abrimos http://localhost:8083 : Activando \"Inspect Features\" podremos ver los atributos de cada elemento. Las teselas est\u00e1n disponibles en: http://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf Incorporando los datos en el visor de Barcelona Sustituiremos el contenido de map.on('load', ...) , y donde antes agreg\u00e1bamos los edificios de catastro en 3D, ahora agregaremos las secciones censales. El c\u00f3digo es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 map . on ( load , function () { map . addSource ( bcn_geodata , { type : vector , tiles : [ http://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf ] }); map . addLayer ({ id : seccion_censal , source : bcn_geodata , source-layer : seccion_censal , type : fill , paint : { fill-opacity : 0.6 , fill-color : #fcc , fill-outline-color : #000 } }); }); Tem\u00e1tico avanzado Expresiones matem\u00e1ticas En las tablas tenemos los campos de poblaci\u00f3n divididos en hombres ( homes ) y mujeres ( dones ), as\u00ed como el \u00e1rea en m\u00b2 de cada secci\u00f3n. Con estos datos, podemos calcular la densidad de poblaci\u00f3n en habitantes/km\u00b2 seg\u00fan la f\u00f3rmula: 1 densidad = (homes+dones)/(area/1000000) El estilo de mapbox-gl permite expresar operaciones matem\u00e1ticas usando expresiones , de la forma: [\"+\", [\"get\", \"homes\"], [\"get\", \"dones\"]] para sumar la poblaci\u00f3n de hombres y de mujeres [\"/\", [\"get\", \"area\"], 1000000] para pasar el \u00e1rea de m\u00b2 a km\u00b2 Y, combinando ambas, obtenemos la densidad de poblaci\u00f3n en habitantes/km\u00b2: 1 2 3 4 [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ] Rampas de color As\u00ed mismo, las expresiones de los estilos de mapbox-gl nos permiten aplicar un n\u00famero discreto de valores de salida a rangos de entrada . Las definiciones del manual sin un ejemplo concreto son algo dif\u00edciles de leer: 1 2 3 4 5 6 [ step , input: number , stop_output_ 0 : OutputType , stop_input_ 1 : number , stop_output_ 1 : OutputType , stop_input_n: number , stop_output_n: OutputType , ... ] : OutputType Pero supongamos que queremos aplicar esta expresi\u00f3n para asignar tres colores en funci\u00f3n de rangos de densidad ( 10.000 hab/km\u00b2 , de 10.000 a 25.000 hab/km\u00b2 , y 25.000 hab/km\u00b2 ), la expresi\u00f3n ser\u00eda: 1 2 3 4 5 6 [ step , [ get , densidad ], Color_1 , 10000 , Color_2 , 25000 , Color_3 ] M\u00e1s sencillo de lo que parec\u00eda. Combinando ambas expresiones Podemos combinar ambas expresiones: \"calcula la densidad y luego asigna un color en funci\u00f3n de su valor\" 1 2 3 4 5 6 7 8 9 10 11 12 13 [ step , [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ], #3d5941 , 17703 , #778868 , 29678 , #b5b991 , 37617 , #f6edbd , 46016 , #edbb8a , 54401 , #de8a5a , 66570 , #ca562c ] Tip Los valores de corte para los diferentes colore se han obtenido calculando los cuantiles con PostgreSQL: 1 2 3 4 5 6 7 SELECT ntile , CAST ( min ( densitat ) AS INTEGER ) AS minAmount , CAST ( max ( densitat ) AS INTEGER ) AS maxAmount FROM ( SELECT ( homes + dones ) / ( area / 1000000 ) as densitat , ntile ( 7 ) OVER ( ORDER BY ( homes + dones ) / ( area / 1000000 )) AS ntile FROM seccion_censal ) x GROUP BY ntile ORDER BY ntile ; Y la rampa de color y sus valores RGB de cada color se han obtenido de carto-colors , que a su vez est\u00e1n inspirados en ColorBrewer. Aplicada a la propiedad fill-color del estilo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 map . addLayer ({ id : seccion_censal , source : bcn_geodata , source-layer : seccion_censal , type : fill , paint : { fill-opacity : 0.75 , fill-color : [ step , [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ], #3d5941 , 17703 , #778868 , 29678 , #b5b991 , 37617 , #f6edbd , 46016 , #edbb8a , 54401 , #de8a5a , 66570 , #ca562c ], fill-outline-color : #000 } }); Obtendremos: Ejercicio extra: A\u00f1adir extrusi\u00f3n 3D Aplicar una extrusi\u00f3n a cada secci\u00f3n censal de altura proporcional a su densidad de poblaci\u00f3n:","title":"C\u00f3mo servir datos din\u00e1micos"},{"location":"7_servidor_dinamico/#como-servir-datos-dinamicos","text":"Partiremos de unos datos con los distritos, barrios y secciones censales de Barcelona. Los datos est\u00e1n en datos/bcn_geodata.sql . Note El origen de los datos es Ajuntament de Barcelona CC-by ( http://w20.bcn.cat/cartobcn/ ). Mart\u00edn Gonz\u00e1lez los convirti\u00f3 a GeoJSON ( https://github.com/martgnz/bcn-geodata ). Para el taller los hemos convertido de GeoJSON a PostGIS. Cargarlos en PostGIS: 1 2 cd ~/Desktop/taller-vt psql -U user datos/bcn_geodata.sql Se crear\u00e1 una BDD bcn_geodata con las tablas barrios , distritos y seccion_censal . Se puede acceder a esta BDD con el usuario user , password user . Una vez con los datos cargados en PostGIS, usaremos tegola para levantar un servidor de teselas vectoriales partir de una BDD PostGIS.","title":"C\u00f3mo servir datos din\u00e1micos"},{"location":"7_servidor_dinamico/#instalando-tegola","text":"Tegola consiste en un solo fichero ejecutable. La instalaci\u00f3n consiste en descargarse un zip, descomprimirlo, y copiar el fichero ejecutable resultante en una ruta localizable: 1 2 3 wget https://github.com/go-spatial/tegola/releases/download/v0.6.3/tegola_linux_amd64.zip unzip tegola_linux_amd64.zip sudo mv tegola_linux_amd64 /usr/local/bin/tegola Comprobar que puede ejecutarse tegola correctamente, y borrar el zip: 1 2 tegola -h # comprobar instalacion rm tegola_linux_amd64.zip","title":"Instalando Tegola"},{"location":"7_servidor_dinamico/#configurando-tegola","text":"Tegola necesita de un fichero de configuraci\u00f3n en formato toml para funcionar. En \u00e9l estableceremos los par\u00e1metros de conexi\u00f3n con la BDD y las caracter\u00edsticas de las capas que queremos servir. Creemos pues un directorio llamado tegola , y en \u00e9l, un fichero llamado config.toml . 1 2 3 mkdir tegola cd tegola touch config.toml Lo primero es definir una secci\u00f3n con el puerto que usaremos para levantar el servicio: 1 2 [webserver] port = :8083 A continuaci\u00f3n definimos la conexi\u00f3n con la BDD en una secci\u00f3n providers . Dentro del provider, definimos las capas de datos que queremos obtener de la BDD. En nuestro caso son muy sencillas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [[providers]] name = postgis type = postgis host = localhost port = 5432 database = bcn_geodata user = user password = user [[providers.layers]] name = distritos tablename = distritos [[providers.layers]] name = barrios tablename = barrios [[providers.layers]] name = seccion_censal tablename = seccion_censal En estas providers.layers tambi\u00e9n se podr\u00edan seleccionar qu\u00e9 columnas queremos obtener, o incluso indicar una consulta SQL para generar la capa, haciendo JOIN de varias tablas, aplicando operaciones espaciales, etc. En nuestro caso, servimos las tablas tal cual. Finalmente, creamos una secci\u00f3n maps , que consiste en un nombre, y una serie de capas de informaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [[maps]] name = bcn_geodata attribution = CC-by Ajuntament de Barcelona center = [2.175, 41.39, 13.0] bounds = [1.898, 41.246, 2.312, 41.533] [[maps.layers]] provider_layer = postgis.seccion_censal dont_simplify = true min_zoom = 11 max_zoom = 16 [[maps.layers]] provider_layer = postgis.barrios dont_simplify = true min_zoom = 10 max_zoom = 16 [[maps.layers]] provider_layer = postgis.distritos dont_simplify = true min_zoom = 0 max_zoom = 16 En estas maps.layers se indican par\u00e1metros para la generaci\u00f3n de las VT, como el rango de niveles de zoom en las que ser\u00e1n visibles, si se simplificar\u00e1 o no la geometr\u00eda. En la configuraci\u00f3n tambi\u00e9n existe la posibilidad de activar una cach\u00e9 en disco, en s3 o en redis, as\u00ed como comandos para invalidar partes de la cach\u00e9. En nuestro caso, no hemos usado cach\u00e9.","title":"Configurando Tegola"},{"location":"7_servidor_dinamico/#arrancando-tegola","text":"Arrancamos el servicio desde el directorio donde hayamos guardato config.toml : 1 2 ~/Desktop/taller-vt/tegola tegola serve Y abrimos http://localhost:8083 : Activando \"Inspect Features\" podremos ver los atributos de cada elemento. Las teselas est\u00e1n disponibles en: http://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf","title":"Arrancando tegola"},{"location":"7_servidor_dinamico/#incorporando-los-datos-en-el-visor-de-barcelona","text":"Sustituiremos el contenido de map.on('load', ...) , y donde antes agreg\u00e1bamos los edificios de catastro en 3D, ahora agregaremos las secciones censales. El c\u00f3digo es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 map . on ( load , function () { map . addSource ( bcn_geodata , { type : vector , tiles : [ http://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf ] }); map . addLayer ({ id : seccion_censal , source : bcn_geodata , source-layer : seccion_censal , type : fill , paint : { fill-opacity : 0.6 , fill-color : #fcc , fill-outline-color : #000 } }); });","title":"Incorporando los datos en el visor de Barcelona"},{"location":"7_servidor_dinamico/#tematico-avanzado","text":"","title":"Tem\u00e1tico avanzado"},{"location":"7_servidor_dinamico/#expresiones-matematicas","text":"En las tablas tenemos los campos de poblaci\u00f3n divididos en hombres ( homes ) y mujeres ( dones ), as\u00ed como el \u00e1rea en m\u00b2 de cada secci\u00f3n. Con estos datos, podemos calcular la densidad de poblaci\u00f3n en habitantes/km\u00b2 seg\u00fan la f\u00f3rmula: 1 densidad = (homes+dones)/(area/1000000) El estilo de mapbox-gl permite expresar operaciones matem\u00e1ticas usando expresiones , de la forma: [\"+\", [\"get\", \"homes\"], [\"get\", \"dones\"]] para sumar la poblaci\u00f3n de hombres y de mujeres [\"/\", [\"get\", \"area\"], 1000000] para pasar el \u00e1rea de m\u00b2 a km\u00b2 Y, combinando ambas, obtenemos la densidad de poblaci\u00f3n en habitantes/km\u00b2: 1 2 3 4 [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ]","title":"Expresiones matem\u00e1ticas"},{"location":"7_servidor_dinamico/#rampas-de-color","text":"As\u00ed mismo, las expresiones de los estilos de mapbox-gl nos permiten aplicar un n\u00famero discreto de valores de salida a rangos de entrada . Las definiciones del manual sin un ejemplo concreto son algo dif\u00edciles de leer: 1 2 3 4 5 6 [ step , input: number , stop_output_ 0 : OutputType , stop_input_ 1 : number , stop_output_ 1 : OutputType , stop_input_n: number , stop_output_n: OutputType , ... ] : OutputType Pero supongamos que queremos aplicar esta expresi\u00f3n para asignar tres colores en funci\u00f3n de rangos de densidad ( 10.000 hab/km\u00b2 , de 10.000 a 25.000 hab/km\u00b2 , y 25.000 hab/km\u00b2 ), la expresi\u00f3n ser\u00eda: 1 2 3 4 5 6 [ step , [ get , densidad ], Color_1 , 10000 , Color_2 , 25000 , Color_3 ] M\u00e1s sencillo de lo que parec\u00eda.","title":"Rampas de color"},{"location":"7_servidor_dinamico/#combinando-ambas-expresiones","text":"Podemos combinar ambas expresiones: \"calcula la densidad y luego asigna un color en funci\u00f3n de su valor\" 1 2 3 4 5 6 7 8 9 10 11 12 13 [ step , [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ], #3d5941 , 17703 , #778868 , 29678 , #b5b991 , 37617 , #f6edbd , 46016 , #edbb8a , 54401 , #de8a5a , 66570 , #ca562c ] Tip Los valores de corte para los diferentes colore se han obtenido calculando los cuantiles con PostgreSQL: 1 2 3 4 5 6 7 SELECT ntile , CAST ( min ( densitat ) AS INTEGER ) AS minAmount , CAST ( max ( densitat ) AS INTEGER ) AS maxAmount FROM ( SELECT ( homes + dones ) / ( area / 1000000 ) as densitat , ntile ( 7 ) OVER ( ORDER BY ( homes + dones ) / ( area / 1000000 )) AS ntile FROM seccion_censal ) x GROUP BY ntile ORDER BY ntile ; Y la rampa de color y sus valores RGB de cada color se han obtenido de carto-colors , que a su vez est\u00e1n inspirados en ColorBrewer. Aplicada a la propiedad fill-color del estilo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 map . addLayer ({ id : seccion_censal , source : bcn_geodata , source-layer : seccion_censal , type : fill , paint : { fill-opacity : 0.75 , fill-color : [ step , [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ], #3d5941 , 17703 , #778868 , 29678 , #b5b991 , 37617 , #f6edbd , 46016 , #edbb8a , 54401 , #de8a5a , 66570 , #ca562c ], fill-outline-color : #000 } }); Obtendremos:","title":"Combinando ambas expresiones"},{"location":"7_servidor_dinamico/#ejercicio-extra-anadir-extrusion-3d","text":"Aplicar una extrusi\u00f3n a cada secci\u00f3n censal de altura proporcional a su densidad de poblaci\u00f3n:","title":"Ejercicio extra: A\u00f1adir extrusi\u00f3n 3D"}]}